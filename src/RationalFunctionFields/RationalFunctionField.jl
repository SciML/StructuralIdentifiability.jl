
"""
    RationalFunctionField

A subfield of the field of rational functions over the rationals.

## Example

```jldoctest
using Nemo
using StructuralIdentifiability: RationalFunctionField

R, (x, y, z) = QQ["x", "y", "z"]

# Constructs a subfield generated by x / y, y / z
rff = RationalFunctionField([x // y, y // z])

# Constructs a subfield generated by y / x, 1 / x, z / y
rff = RationalFunctionField([[x, y, R(1)], [y, z]])
```
"""
mutable struct RationalFunctionField{T}
    dennums::Vector{Vector{T}}
    mqs::IdealMQS{T}

    function RationalFunctionField(polys::Vector{T}) where {T}
        RationalFunctionField(polys .// one(parent(first(polys))))
    end
    function RationalFunctionField(fractions::Vector{Generic.Frac{T}}) where {T}
        RationalFunctionField(fractions_to_dennums(fractions))
    end
    function RationalFunctionField(dennums::Vector{Vector{T}}) where {T}
        @assert !isempty(dennums)
        new{T}(dennums, IdealMQS(dennums))
    end
end

"""
    dennums_to_fractions(dennums)
    
Returns the field generators represented by fractions.

Input: an array of arrays of polynomials, as in 
`[[f1, f2, f3, ...], [g1, g2, g3, ...], ...]`

Output: an array of fractions
`[f2/f1, f3/f1, ..., g2/g1, g3/g1, ...]`
"""
function dennums_to_fractions(dennums::Vector{Vector{T}}) where {T}
    fractions = Vector{AbstractAlgebra.Generic.Frac{T}}()
    for dni in dennums
        den, nums = dni[1], dni[2:end]
        isempty(nums) && continue
        append!(fractions, map(c -> c // den, nums))
    end
    return fractions
end

"""
    fractions_to_dennums(fractions)
    
Returns the field generators represented by lists of denominators and
numerators.

Input: an array of fractions, as in
`[f2/f1, f3/f1, ..., g2/g1, g3/g1, ...]`

Output: an array of arrays of polynomials,
`[[f1, f2, f3, ...], [g1, g2, g3, ...], ...]`
"""
function fractions_to_dennums(fractions)
    return map(f -> [denominator(f), numerator(f)], fractions)
end

"""
    check_field_membership(generators, rat_funcs, p)

Checks whether the given rational functions belong to the given field of
rational functions.

Inputs:
- `generators` - a list of lists of polynomials. Each of the lists, say, `[f1, ..., fn]`,
  defines generators `f2/f1, ..., fn/f1`. Let ``F`` be the field generated by all of them.
- `rat_funcs` - list of rational functions
- `p` - a real number between 0 and 1, the probability of correctness

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function belongs to ``F``. The whole result is correct with probability at least p
"""
function check_field_membership(generators, rat_funcs, p)
    if isempty(generators)
        # TODO: RationalFunctionField of empty set is an error currently
        return fill(false, length(rat_funcs))
    end
    if isempty(rat_funcs)
        return Bool[]
    end
    return check_field_membership(
        RationalFunctionField(generators),
        RationalFunctionField(rat_funcs),
        p,
    )
end

"""
    check_field_membership_mod_p(generators, rat_funcs)

Checks whether the given rational functions belong to the given field of
rational functions over integers modulo a prime.

Inputs:
- `generators` - a list of lists of polynomials. Each of the lists, say, `[f1, ..., fn]`,
  defines generators `f2/f1, ..., fn/f1`. Let ``F`` be the field generated by all of them.
- `rat_funcs` - list of rational functions

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function belongs to ``F``
"""
function check_field_membership_mod_p(generators, rat_funcs)
    if isempty(generators)
        # TODO: RationalFunctionField of empty set is an error currently
        return fill(false, length(rat_funcs))
    end
    if isempty(rat_funcs)
        return Bool[]
    end
    return check_field_membership_mod_p!(
        RationalFunctionField(generators),
        RationalFunctionField(rat_funcs),
    )
end

function check_field_membership(
    generators::RationalFunctionField{T},
    tobereduced::RationalFunctionField{T},
    p,
) where {T}
    @debug "Estimating the sampling bound"
    pivots_generators = generators.mqs.dens_qq
    pivots_tobereduced = tobereduced.mqs.dens_qq
    den_lcm = lcm(generators.mqs.den_lcm, tobereduced.mqs.den_lcm)
    degree = total_degree(den_lcm) + 1
    for (i, plist) in enumerate(generators.dennums)
        extra_degree = total_degree(den_lcm) - total_degree(pivots_generators[i])
        degree = max(degree, extra_degree + maximum(total_degree, plist))
    end
    for (i, plist) in enumerate(tobereduced.dennums)
        extra_degree = total_degree(den_lcm) - total_degree(pivots_tobereduced[i])
        degree = max(degree, extra_degree + maximum(total_degree, plist))
    end
    @debug "\tBound for the degrees is $degree"
    total_vars = foldl(
        union,
        map(plist -> foldl(union, map(poly -> Set(vars(poly)), plist)), generators.dennums),
    )
    @debug "\tThe total number of variables in $(length(total_vars))"
    sampling_bound = BigInt(
        3 *
        BigInt(degree)^(length(total_vars) + 3) *
        (length(tobereduced.mqs.nums_qq)) *
        ceil(1 / (1 - p)),
    )
    @debug "\tSampling from $(-sampling_bound) to $(sampling_bound)"
    mqs_generators = generators.mqs
    mqs_tobereduced = tobereduced.mqs
    param_ring = ParamPunPam.parent_params(mqs_generators)
    point = map(v -> Nemo.QQ(rand((-sampling_bound):sampling_bound)), gens(param_ring))
    gens_specialized = specialize(mqs_generators, point)
    tbr_specialized = specialize(mqs_tobereduced, point, saturated = false)
    @debug "Computing Groebner basis ($(length(gens_specialized)) equations)"
    @assert parent(first(gens_specialized)) == parent(first(tbr_specialized))
    gb = groebner(gens_specialized)
    result = map(iszero, normalform(gb, tbr_specialized))
    return result
end

function check_field_membership_mod_p!(
    generators::RationalFunctionField{T},
    tobereduced::RationalFunctionField{T},
) where {T}
    mqs_generators = generators.mqs
    mqs_tobereduced = tobereduced.mqs
    ff = Nemo.GF(2^31 - 1)
    reduce_mod_p!(mqs_generators, ff)
    reduce_mod_p!(mqs_tobereduced, ff)
    param_ring = ParamPunPam.parent_params(mqs_generators)
    point = ParamPunPam.distinct_nonzero_points(ff, nvars(param_ring))
    gens_specialized = ParamPunPam.specialize_mod_p(mqs_generators, point)
    polys_specialized =
        ParamPunPam.specialize_mod_p(mqs_tobereduced, point, saturated = false)
    @assert parent(first(gens_specialized)) == parent(first(polys_specialized))
    gb = groebner(gens_specialized)
    nf = normalform(gb, polys_specialized)
    result = map(iszero, nf)
    return result
end

"""
    beautifuly_generators(rff::RationalFunctionField)

Given a field of rational functions `rff` returns a set of "simpler" and
standardized generators for `rff`.

Applies the following passes:
1. Filter constants,
2. Remove redundant generators.
"""
function beautifuly_generators(
    rff::RationalFunctionField;
    discard_redundant = true,
    reversed_order = false,
)
    fracs = dennums_to_fractions(rff.dennums)
    # Filter pass
    fracs = filter(!is_rational_func_const, fracs)
    if isempty(fracs)
        @debug "The set of generators is empty"
        return fracs
    end
    # Remove redundant pass
    if discard_redundant
        sort!(fracs, lt = rational_func_cmp)
        @info "The pool of fractions:\n$(join(map(repr, fracs), ",\n"))"
        if reversed_order
            non_redundant = collect(1:length(fracs))
            for i in length(fracs):-1:1
                func = fracs[i]
                if length(non_redundant) == 1
                    continue
                end
                result =
                    check_field_membership_mod_p(fracs[setdiff(non_redundant, i)], [func])
                @debug "Simplification: inclusion check" func result
                if result[1]
                    @debug "The function $func is discarded"
                    setdiff!(non_redundant, i)
                end
            end
        else
            non_redundant = Vector{Int}()
            push!(non_redundant, 1)
            for i in 2:length(fracs)
                func = fracs[i]
                result = check_field_membership_mod_p(fracs[non_redundant], [func])
                @debug "Simplification: inclusion check" func result
                if !result[1]
                    @debug "The function $func is included in the set of generators"
                    push!(non_redundant, i)
                end
            end
        end
        @debug "Out of $(length(fracs)) simplified generators there are $(length(non_redundant)) non redundant"
        fracs = fracs[non_redundant]
    end
    sort!(fracs, lt = rational_func_cmp)
    spring_cleaning_pass!(fracs)
    return fracs
end

"""
    rational_func_cmp(f, g)

Returns `true` iff `f < g`. 

*This is a strict total order, which ensures the uniqueness of a sorting
permutation.*

First compare the number of terms in the numerator and denominator.
Break ties by comparing the total degrees of the numerator and denominator.
Break ties by comparing the monomials of the numerator and denominator.
"""
function rational_func_cmp(f, g)
    flag = compare_rational_func_by(f, g, !is_constant)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, is_constant, :denominator)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, length, :additive)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, total_degree)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, leading_monomial)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, collect ∘ monomials)
    flag == 1 && return false
    flag == -1 && return true
    return false
end

function spring_cleaning_pass!(fracs)
    @assert all(is_rational_func_normalized, fracs)
    for i in 1:length(fracs)
        func = fracs[i]
        num, den = unpack_fraction(func)
        if is_constant(num)
            func = den // num
        end
        num, den = unpack_fraction(func)
        if leading_coefficient(num) < 0
            func = func * leading_coefficient(num)
        end
        num, den = unpack_fraction(func)
        if is_constant(den) && is_constant(Nemo.term(num, length(num)))
            func = (num - trailing_coefficient(num)) // one(num)
        end
        fracs[i] = func
    end
    fracs
end

"""
    groebner_basis_coeffs(rff; options...)

## Options

- `ordering`: GB ordering; must be one of the orderings exported by
  `ParamPunPam` or `Groebner`.
- `up_to_degree`: a tuple of integers, the degrees of numerator and denominator.
    The result is correct up to the requested degrees.
"""
function groebner_basis_coeffs(
    rff::RationalFunctionField;
    seed = 42,
    ordering = Groebner.InputOrdering(),
    up_to_degree = (typemax(Int), typemax(Int)),
)
    mqs = rff.mqs
    gb, fracs, new_rff = nothing, nothing, nothing
    # Check if the basis is in cache
    if haskey(mqs.groebner_bases, ordering)
        @debug "Cache hit with ($ordering)"
        gb = mqs.groebner_bases[ordering]
        basis_coeffs = map(collect ∘ coefficients, gb)
        fracs = collect(mapreduce(Set, union!, basis_coeffs))
        return RationalFunctionField(fracs)
    end
    _runtime_logger[:id_calls_to_gb] += 1
    current_degrees = (2, 2)
    two_sided_inclusion = false
    while !two_sided_inclusion && all(current_degrees .<= up_to_degree)
        @debug "Computing GB with parameters up to degrees $(current_degrees)"
        runtime = @elapsed gb = ParamPunPam.paramgb(
            mqs,
            up_to_degree = current_degrees,
            seed = seed,
            ordering = ordering,
        )
        _runtime_logger[:id_groebner_time] += runtime
        @info "Groebner basis computed in $runtime seconds"
        basis_coeffs = map(collect ∘ coefficients, gb)
        basis_coeffs_set = mapreduce(Set, union!, basis_coeffs)
        fracs = collect(basis_coeffs_set)
        @debug "Generators up to degrees $(current_degrees) are" fracs
        @info "Checking two-sided inclusion modulo a prime"
        time_start = time_ns()
        # Check inclusion: <simplified generators> in <original generators> 
        new_rff = RationalFunctionField(fracs)
        inclusion = check_field_membership_mod_p!(rff, new_rff)
        two_sided_inclusion = two_sided_inclusion || all(inclusion)
        # Check inclusion: <original generators> in <simplified generators>
        inclusion = check_field_membership_mod_p!(new_rff, rff)
        runtime = (time_ns() - time_start) / 1e9
        _runtime_logger[:id_inclusion_check_mod_p] += runtime
        @info "Inclusion checked in $(runtime) seconds. Result: $two_sided_inclusion"
        two_sided_inclusion = two_sided_inclusion && all(inclusion)
        current_degrees = current_degrees .* 2
    end
    @info "The coefficients of the Groebner basis are presented by $(length(fracs)) rational functions"
    new_rff.mqs.groebner_bases[ordering] = gb
    rff.mqs.groebner_bases[ordering] = gb
    return new_rff
end

"""
    linear_relations_between_normal_forms(rff, up_to_degree)

Returns the generators of the rational function field `rff` obtained as
relations over the rationals between the normal forms of the monomials up to the
degree.
"""
function linear_relations_between_normal_forms(
    rff::RationalFunctionField{T},
    up_to_degree::Integer;
    seed = 42,
) where {T}
    @assert up_to_degree > 0
    time_start = time_ns()
    @info "Computing linear relations of monomials up to degree $up_to_degree"
    # NOTE: this is not fair regarding mutation and `!`
    groebner_basis_coeffs(rff)
    gb = first(values(rff.mqs.groebner_bases))
    R = parent(gb[1])
    Rparam = base_ring(base_ring(R))
    xs = gens(R)
    @assert rff.mqs.sat_var_index == length(xs)
    xs = xs[1:(end - 1)]
    # Compute normal forms
    normal_forms = Vector{elem_type(R)}(undef, 0)
    monoms = Vector{elem_type(R)}(undef, 0)
    for deg in 1:up_to_degree
        for combination in Combinatorics.with_replacement_combinations(xs, deg)
            monom = prod(combination)
            @debug "Computing the normal form of" monom
            _, nf = divrem(monom, gb)
            push!(monoms, monom)
            push!(normal_forms, nf)
        end
    end
    @info "Computing the normal forms of $(length(monoms)) monomials (variables: $(length(xs)), degree: $(up_to_degree))"
    # Backward Gaussian elimination over QQ.
    #
    # If a polynomial in QQ(a)[x] is reduced to a fraction in QQ(a), then the
    # fraction belongs to the field. 
    # Constants belong to the field by construction.
    # TODO: this does not handle reduction properly for the case when
    # normal_forms[i] is a sum of a constant and a polynomial
    constants = map(f -> coeff(f, 1), filter(is_constant, normal_forms))
    @debug "Constant elements of the MQS ideal are" constants
    generators = constants
    permutation = collect(1:length(normal_forms))
    filter!(i -> !is_constant(normal_forms[i]), permutation)
    # The first monom is the smallest
    sort!(permutation, by = i -> leading_monomial(normal_forms[i]))
    normal_forms = normal_forms[permutation]
    monoms = monoms[permutation]
    n = length(normal_forms)
    for i in 2:n
        # Reduce nf[i] with nf[1..i-1]
        nfi = normal_forms[i]
        qq_coeffs = map(_ -> Nemo.QQ(0), 1:n)
        qq_coeffs[i] = one(qq_coeffs[i])
        @debug "Reducing element over QQ" nfi
        for j in 1:(i - 1)
            nfj = normal_forms[j]
            is_constant(nfj) && continue
            leadj = leading_monomial(nfj)
            ci = coeff(nfi, leadj)
            # If fi contains the lead of fj
            iszero(ci) && continue
            cj = leading_coefficient(nfj)
            cij = div(ci, cj)
            # If the result of division belongs to QQ.
            # NOTE: ci, cj, cij are elements of Q(a)
            !is_rational_func_const(cij) && continue
            nfi = nfi - cij * nfj
            qq_coeffs[j] = -coeff(numerator(cij), 1)
        end
        # If the result of reduction belongs to QQ(a).
        # NOTE: normal_forms[i] is an elements of QQ(a)[x] 
        if iszero(nfi)
            @info "" monoms qq_coeffs normal_forms
            preimage = sum(map(i -> monoms[i] * qq_coeffs[i], 1:n))
            # TODO: A dirty hack!
            @assert rff.mqs.sat_var_index == length(xs)
            preimage = parent_ring_change(preimage, Rparam, matching = :byindex)
            push!(generators, preimage)
        end
        if is_constant(nfi)
            push!(generators, coeff(nfi, 1))
        end
    end
    _runtime_logger[:id_normalforms_time] = (time_ns() - time_start) / 1e9
    @info "Generators from normal forms" generators
    generators, monoms, normal_forms
end

"""
    generating_sets_fan(rff::RationalFunctionField, nbases)

Returns a set of Groebner bases for multiple different rankings of variables.

## Arguments

- `nbases`: How many bases to compute.
- Keyword `up_to_degree`: a tuple of integers, max. degrees of numerators and
  denominators. Result is correct up to the requested degrees.
"""
function generating_sets_fan(
    rff::RationalFunctionField{T},
    nbases::Integer;
    seed = 42,
    up_to_degree = (3, 3),
) where {T}
    @info "Computing $nbases Groebner bases for each of the $nbases block orderings"
    time_start = time_ns()
    vars = gens(parent(rff.mqs))
    ordering_to_generators = Dict()
    # The first basis is in degrevlex
    ord = DegRevLex()
    new_rff = groebner_basis_coeffs(rff, seed = seed, ordering = ord)
    cfs = beautifuly_generators(new_rff)
    ordering_to_generators[ord] = cfs
    if isempty(cfs)
        return ordering_to_generators
    end
    # NOTE: maybe hide the computation of multiple bases inside
    # RationalFunctionField
    gb_rff = RationalFunctionField(cfs)
    for _ in 1:nbases
        vars_shuffled = shuffle(vars)
        n = length(vars_shuffled)
        n1, n2 = div(n, 2), n - div(n, 2)
        ord = DegRevLex(vars_shuffled[1:n1]) * DegRevLex(vars_shuffled[(n1 + 1):end])
        @info "Computing GB for ordering" ord
        new_rff = groebner_basis_coeffs(
            gb_rff,
            seed = seed,
            ordering = ord,
            up_to_degree = up_to_degree,
        )
        cfs = beautifuly_generators(new_rff, discard_redundant = false)
        ordering_to_generators[ord] = cfs
    end
    _runtime_logger[:id_gbfan_time] = (time_ns() - time_start) / 1e9
    ordering_to_generators
end

"""
    simplified_generating_set(rff; p = 0.99, seed = 42)

Returns a simplified set of generators for `rff`. 
Result is correct (in Monte-Carlo sense) with probability at least `p`.
"""
function simplified_generating_set(
    rff::RationalFunctionField;
    p = 0.99,
    seed = 42,
    strategy = (:gb,),
)
    # TODO: use seed!
    # TODO: there are a lot of redundant functions coming from normal forms and
    # the coefficients of GBs. Maybe filter them preemtively, before creating a
    # RFF
    @info "Simplifying identifiable functions"
    _runtime_logger[:id_groebner_time] = 0.0
    _runtime_logger[:id_calls_to_gb] = 0
    _runtime_logger[:id_inclusion_check_mod_p] = 0.0
    _runtime_logger[:id_inclusion_check] = 0.0
    _runtime_logger[:id_beautifulization] = 0.0
    _runtime_logger[:id_gbfan_time] = 0.0
    _runtime_logger[:id_normalforms_time] = 0.0
    # Compute the first GB in some ordering
    new_rff = groebner_basis_coeffs(rff, seed = seed)
    new_fracs = beautifuly_generators(new_rff)
    if isempty(new_fracs)
        return new_fracs
    end
    # If a set of GBs is needed
    if first(strategy) === :gbfan
        @assert length(strategy) == 2
        _, nbases = strategy
        fan = generating_sets_fan(new_rff, nbases; seed = seed)
        for (ord, generators) in fan
            append!(new_fracs, generators)
        end
    end
    # If normal forms are needed
    if first(strategy) === :normalforms
        @assert length(strategy) == 2
        _, up_to_degree = strategy
        generators, _, _ =
            linear_relations_between_normal_forms(new_rff, up_to_degree; seed = seed)
        append!(new_fracs, generators)
    end
    # Something in the middle
    if first(strategy) === :hybrid
        @assert length(strategy) == 1
        # Compute some normal forms
        up_to_degree = 3
        generators, _, _ =
            linear_relations_between_normal_forms(new_rff, up_to_degree; seed = seed)
        append!(new_fracs, generators)
        # Now, generators from normal forms may contain simpler functions, so we
        # update the function field to account for that
        new_rff =
            RationalFunctionField(beautifuly_generators(RationalFunctionField(new_fracs)))
        # Compute some GBs
        nbases = 5
        fan = generating_sets_fan(new_rff, nbases; seed = seed)
        for (ord, generators) in fan
            append!(new_fracs, generators)
        end
    end
    @info "Final cleaning and simplification of generators"
    runtime = @elapsed new_fracs = beautifuly_generators(RationalFunctionField(new_fracs))
    _runtime_logger[:id_beautifulization] += runtime
    @info "Checking inclusion with probability $p"
    runtime =
        @elapsed result = check_field_membership(RationalFunctionField(new_fracs), rff, p)
    _runtime_logger[:id_inclusion_check] = runtime
    @info "Inclusion checked in $(_runtime_logger[:id_inclusion_check]) seconds. Result: $(all(result))"
    if !all(result)
        @warn "Field membership check failed. Error will follow."
        throw("The new subfield generators are not correct.")
    end
    @info "Out of $(length(rff.mqs.nums_qq)) initial generators there are $(length(new_fracs)) indepdendent"
    return new_fracs
end
