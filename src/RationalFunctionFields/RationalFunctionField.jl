
"""
    RationalFunctionField

A subfield of the field of rational functions over the rationals.

## Example

```jldoctest
using Nemo
using StructuralIdentifiability: RationalFunctionField

R, (x, y, z) = QQ["x", "y", "z"]

# Constructs a subfield generated by <x / y, y / z>
rff = RationalFunctionField([x // y, y // z])

# Constructs a subfield generated by <y / x, 1 / x, z / y>
rff = RationalFunctionField([[x, y, R(1)], [y, z]])
```
"""
mutable struct RationalFunctionField{T}
    dennums::Vector{Vector{T}}
    mqs::IdealMQS{T}

    function RationalFunctionField(polys::Vector{T}) where {T}
        RationalFunctionField(polys .// one(parent(first(polys))))
    end
    function RationalFunctionField(fractions::Vector{Generic.Frac{T}}) where {T}
        RationalFunctionField(fractions_to_dennums(fractions))
    end
    function RationalFunctionField(dennums::Vector{Vector{T}}) where {T}
        @assert !isempty(dennums)
        new{T}(dennums, IdealMQS(dennums))
    end
end

"""
    dennums_to_fractions(dennums)
    
Returns the field generators represented by fractions.

Input: an array of arrays of polynomials, as in 
`[[f1, f2, f3, ...], [g1, g2, g3, ...], ...]`

Output: an array of fractions
`[f2/f1, f3/f1, ..., g2/g1, g3/g1, ...]`
"""
function dennums_to_fractions(dennums::Vector{Vector{T}}) where {T}
    fractions = Vector{AbstractAlgebra.Generic.Frac{T}}()
    for dni in dennums
        den, nums = dni[1], dni[2:end]
        isempty(nums) && continue
        append!(fractions, map(c -> c // den, nums))
    end
    return fractions
end

"""
    fractions_to_dennums(fractions)
    
Returns the field generators represented by lists of denominators and
numerators.

Input: an array of fractions, as in
`[f2/f1, f3/f1, ..., g2/g1, g3/g1, ...]`

Output: an array of arrays of polynomials,
`[[f1, f2, f3, ...], [g1, g2, g3, ...], ...]`
"""
function fractions_to_dennums(fractions)
    map(f -> [denominator(f), numerator(f)], fractions)
end

"""
    check_field_membership(generators, rat_funcs, p)

Checks whether given rational functions belong to a given field of rational functions

Inputs:
- `generators` - a list of lists of polynomials. Each of the lists, say, `[f1, ..., fn]`,
  defines generators `f2/f1, ..., fn/f1`. Let ``F`` be the field generated by all of them.
- `rat_funcs` - list of rational functions
- `p` - a real number between 0 and 1, the probability of correctness

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function belongs to ``F``. The whole result is correct with probability at least p
"""
function check_field_membership(generators, rat_funcs, p)
    if isempty(generators)
        # TODO: RationalFunctionField of empty set is an error currently
        return fill(false, length(rat_funcs))
    end
    if isempty(rat_funcs)
        return Bool[]
    end
    check_field_membership(
        RationalFunctionField(generators),
        RationalFunctionField(rat_funcs),
        p,
    )
end

"""
    check_field_membership_mod_p(generators, rat_funcs)

Checks whether given rational functions belong to a given field of rational
functions over integers modulo a prime

Inputs:
- `generators` - a list of lists of polynomials. Each of the lists, say, `[f1, ..., fn]`,
  defines generators `f2/f1, ..., fn/f1`. Let ``F`` be the field generated by all of them.
- `rat_funcs` - list of rational functions

Output:
- a list `L[i]` of bools of length `length(rat_funcs)` such that `L[i]` is true iff
   the i-th function belongs to ``F``
"""
function check_field_membership_mod_p(generators, rat_funcs)
    if isempty(generators)
        # TODO: RationalFunctionField of empty set is an error currently
        return fill(false, length(rat_funcs))
    end
    if isempty(rat_funcs)
        return Bool[]
    end
    check_field_membership_mod_p!(
        RationalFunctionField(generators),
        RationalFunctionField(rat_funcs),
    )
end

function check_field_membership(
    generators::RationalFunctionField{T},
    tobereduced::RationalFunctionField{T},
    p,
) where {T}
    @debug "Estimating the sampling bound"
    pivots_generators = generators.mqs.dens_qq
    pivots_tobereduced = tobereduced.mqs.dens_qq
    den_lcm = lcm(generators.mqs.den_lcm, tobereduced.mqs.den_lcm)
    degree = total_degree(den_lcm) + 1
    for (i, plist) in enumerate(generators.dennums)
        extra_degree = total_degree(den_lcm) - total_degree(pivots_generators[i])
        degree = max(degree, extra_degree + maximum(total_degree, plist))
    end
    for (i, plist) in enumerate(tobereduced.dennums)
        extra_degree = total_degree(den_lcm) - total_degree(pivots_tobereduced[i])
        degree = max(degree, extra_degree + maximum(total_degree, plist))
    end
    @debug "\tBound for the degrees is $degree"
    total_vars = foldl(
        union,
        map(plist -> foldl(union, map(poly -> Set(vars(poly)), plist)), generators.dennums),
    )
    @debug "\tThe total number of variables in $(length(total_vars))"
    sampling_bound = BigInt(
        3 *
        BigInt(degree)^(length(total_vars) + 3) *
        (length(tobereduced.mqs.nums_qq)) *
        ceil(1 / (1 - p)),
    )
    @debug "\tSampling from $(-sampling_bound) to $(sampling_bound)"
    mqs_generators = generators.mqs
    mqs_tobereduced = tobereduced.mqs
    param_ring = ParamPunPam.parent_params(mqs_generators)
    point = map(v -> Nemo.QQ(rand((-sampling_bound):sampling_bound)), gens(param_ring))
    gens_specialized = specialize(mqs_generators, point)
    tbr_specialized = specialize(mqs_tobereduced, point, saturated = false)
    @debug "Computing Groebner basis ($(length(gens_specialized)) equations)"
    @assert parent(first(gens_specialized)) == parent(first(tbr_specialized))
    gb = groebner(gens_specialized)
    result = map(iszero, normalform(gb, tbr_specialized))
    return result
end

function check_field_membership_mod_p!(
    generators::RationalFunctionField{T},
    functions::RationalFunctionField{T},
) where {T}
    mqs_generators = generators.mqs
    mqs_tobereduced = functions.mqs
    ff = Nemo.GF(2^31 - 1)
    reduce_mod_p!(mqs_generators, ff)
    reduce_mod_p!(mqs_tobereduced, ff)
    param_ring = ParamPunPam.parent_params(mqs_generators)
    point = ParamPunPam.distinct_nonzero_points(ff, nvars(param_ring))
    gens_specialized = ParamPunPam.specialize_mod_p(mqs_generators, point)
    polys_specialized =
        ParamPunPam.specialize_mod_p(mqs_tobereduced, point, saturated = false)
    @assert parent(first(gens_specialized)) == parent(first(polys_specialized))
    gb = groebner(gens_specialized)
    nf = normalform(gb, polys_specialized)
    result = map(iszero, nf)
    return result
end

"""
    beautifuly_generators(rff::RationalFunctionField)

Given a field of rational functions `rff` returns a set of "simple" and
standardized generators for `rff`.

Applies the following passes:
1. Filter constants,
2. Remove redundant generators,
3. Maayybe put generators in the autoreduced state,
"""
function beautifuly_generators(rff::RationalFunctionField, rewrite_pass = true)
    id_funcs = dennums_to_fractions(rff.dennums)
    # Filter pass
    id_funcs = filter(!is_rational_func_const, id_funcs)
    if isempty(id_funcs)
        @debug "The set of identifiabile functions is empty"
        return id_funcs
    end
    # Remove redundant pass
    sort!(id_funcs, lt = rational_func_cmp)
    non_redundant = collect(1:length(id_funcs))
    for i in length(id_funcs):-1:1
        func = id_funcs[i]
        if length(non_redundant) == 1
            continue
        end
        result = check_field_membership_mod_p(id_funcs[setdiff(non_redundant, i)], [func])
        @debug "Simplification: inclusion check" func result
        if result[1]
            @debug "The function $func is discarded"
            setdiff!(non_redundant, i)
        end
    end
    @debug "Out of $(length(id_funcs)) simplified generators there are $(length(non_redundant)) non redundant"
    id_funcs = id_funcs[non_redundant]
    sort!(id_funcs, lt = rational_func_cmp)
    # if rewrite_pass && false
    #     for i in 2:length(id_funcs)
    #         func_nf = symbolic_normal_form(id_funcs[1:(i - 1)], id_funcs[i])
    #         target_orig = length(numerator(id_funcs[i])) + length(denominator(id_funcs[i]))
    #         target_nf = length(numerator(func_nf)) + length(denominator(func_nf))
    #         if target_nf < target_orig
    #             @debug "Rewritten $(id_funcs[i]) with $(func_nf)" target_nf target_orig
    #             id_funcs[i] = func_nf
    #         end
    #     end
    # end
    spling_cleaning_pass!(id_funcs)
    return id_funcs
end

"""
    rational_func_cmp(f, g)

Returns `true` iff `f < g`. 

*This is a strict total order, which ensures the uniqueness of a sorting
permutation.*

First compare the number of terms in the numerator and denominator.
Break ties by comparing the total degrees of the numerator and denominator.
Break ties by comparing the monomials of the numerator and denominator.
"""
function rational_func_cmp(f, g)
    flag = compare_rational_func_by(f, g, !is_constant)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, length, :additive)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, total_degree)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, leading_monomial)
    flag == 1 && return false
    flag == -1 && return true
    flag = compare_rational_func_by(f, g, collect ∘ monomials)
    flag == 1 && return false
    flag == -1 && return true
    return false
end

function spling_cleaning_pass!(id_funcs)
    @assert all(is_rational_func_normalized, id_funcs)
    for i in 1:length(id_funcs)
        func = id_funcs[i]
        num, den = unpack_fraction(func)
        if is_constant(num)
            func = den // num
        end
        num, den = unpack_fraction(func)
        if leading_coefficient(num) < 0
            func = func * leading_coefficient(num)
        end
        num, den = unpack_fraction(func)
        if is_constant(den) && is_constant(Nemo.term(num, length(num)))
            func = (num - trailing_coefficient(num)) // one(num)
        end
        id_funcs[i] = func
    end
    id_funcs
end

"""
    simplified_generating_set(rff::RationalFunctionField; p = 0.99, seed = 42)

Returns a simplified set of generators for `rff`. 
Result is correct (in Monte-Carlo sense) with probability at least `p`.
"""
function simplified_generating_set(rff::RationalFunctionField; p = 0.99, seed = 42)
    # TODO: use seed!
    @info "Simplifying identifiable functions"
    _runtime_logger[:id_groebner_time] = 0.0
    _runtime_logger[:id_inclusion_check_mod_p] = 0.0
    mqs = rff.mqs
    gb, id_funcs, new_rff = nothing, nothing, nothing
    current_degrees = (2, 2)
    two_sided_inclusion = false
    while !two_sided_inclusion
        @debug "Computing GB with parameters up to degrees $(current_degrees)"
        runtime = @elapsed gb =
            ParamPunPam.paramgb(mqs, up_to_degree = current_degrees, seed = seed)
        _runtime_logger[:id_groebner_time] += runtime
        @info "Groebner basis computed in $runtime seconds"
        basis_coeffs = map(collect ∘ coefficients, gb)
        basis_coeffs_set = mapreduce(Set, union!, basis_coeffs)
        id_funcs = collect(basis_coeffs_set)
        @info "Identifiable functions up to degrees $(current_degrees) are" id_funcs
        @info "Checking two-sided inclusion modulo a prime"
        time_start = time_ns()
        # Check inclusion: <simplified generators> in <original generators> 
        new_rff = RationalFunctionField(id_funcs)
        inclusion = check_field_membership_mod_p!(rff, new_rff)
        two_sided_inclusion = two_sided_inclusion || all(inclusion)
        # Check inclusion: <original generators> in <simplified generators>
        inclusion = check_field_membership_mod_p!(new_rff, rff)
        _runtime_logger[:id_inclusion_check_mod_p] += (time_ns() - time_start) / 1e9
        two_sided_inclusion = two_sided_inclusion && all(inclusion)
        @info "Inclusion checked in $(_runtime_logger[:id_inclusion_check_mod_p]) seconds. Result: $two_sided_inclusion"
        current_degrees = current_degrees .* 2
    end
    _runtime_logger[:id_gb_degrees] = current_degrees
    @info "The coefficients of the Groebner basis are presented by $(length(id_funcs)) rational functions"
    time_start = time_ns()
    new_id_funcs = beautifuly_generators(new_rff)
    if isempty(new_id_funcs)
        return new_id_funcs
    end
    _runtime_logger[:id_filter_time] = (time_ns() - time_start) / 1e9
    @info "Functions filtered in $(_runtime_logger[:id_filter_time]) seconds"
    @info "Checking inclusion with probability $p"
    runtime = @elapsed result =
        check_field_membership(RationalFunctionField(new_id_funcs), rff, p)
    _runtime_logger[:id_inclusion_check] = runtime
    @info "Inclusion checked in $(_runtime_logger[:id_inclusion_check]) seconds. Result: $two_sided_inclusion"
    @debug "Results of the check over the rationals:" result
    if !all(result)
        @warn "Field membership check failed. Error will follow."
        throw("The new subfield generators are not correct.")
    end
    @info "Out of $(length(rff.mqs.nums_qq)) initial generators there are $(length(new_id_funcs)) non redundant"
    return new_id_funcs
end
