# ------------------------------------------------------------------------------

function check_primality_zerodim(J::Array{QQMPolyRingElem, 1})
    J = Groebner.groebner(J)
    basis = Groebner.quotient_basis(J)
    dim = length(basis)
    S = Nemo.matrix_space(Nemo.QQ, dim, dim)
    matrices = []
    @debug "Dim is $dim"
    for v in gens(parent(first(J)))
        M = zero(S)
        for (i, vec) in enumerate(basis)
            image = Groebner.normalform(J, v * vec)
            for (j, base_vec) in enumerate(basis)
                M[i, j] = Nemo.QQ(coeff(image, base_vec))
            end
        end
        push!(matrices, M)
    end
    generic_multiplication = sum(Nemo.QQ(rand(1:100)) * M for M in matrices)
    @debug "Generic multiplication matrix computed"
    @debug "Trying reductions over primed first"
    NUM_PRIMES = 10
    p = 2^31 - 1
    for _ in 1:NUM_PRIMES
        @debug "Prime is $p"
        F = Nemo.GF(p)
        S_F = Nemo.matrix_space(F, dim, dim)
        generic_multiplication_modp = S_F([generic_multiplication[i, j] for i in 1:dim for j in 1:dim])
        R, t = Nemo.polynomial_ring(F, "t")
        chpoly = Nemo.charpoly(R, generic_multiplication_modp)
        @debug "Charpoly computed"
        if Nemo.is_irreducible(chpoly)
            return true
        end
        p = Primes.nextprime(p + 1)
    end

    @debug "No conclusion modulo primes, computing over Q"
    R, t = Nemo.polynomial_ring(Nemo.QQ, "t")
    chpoly = Nemo.charpoly(R, generic_multiplication)

    return Nemo.is_irreducible(chpoly)
end

#------------------------------------------------------------------------------
"""
    check_primality(polys::Dict{QQMPolyRingElem, QQMPolyRingElem}, extra_relations::Array{QQMPolyRingElem, 1})

The function checks if the ideal generated by the polynomials and saturated at
the leading coefficient with respect to the corresponding variables is prime
over rationals.

The `extra_relations` allows adding more polynomials to the generators (not affecting the saturation).
"""
function check_primality(
        polys::Dict{QQMPolyRingElem, QQMPolyRingElem},
        extra_relations::Array{QQMPolyRingElem, 1},
    )
    leaders = collect(keys(polys))
    ring = parent(leaders[1])

    Rspec, vspec = Nemo.polynomial_ring(Nemo.QQ, [var_to_str(l) for l in leaders])
    eval_point = [v in keys(polys) ? v : ring(rand(1:100)) for v in gens(ring)]
    all_polys = vcat(collect(values(polys)), extra_relations)
    zerodim_ideal =
        collect(map(p -> parent_ring_change(evaluate(p, eval_point), Rspec), all_polys))

    return check_primality_zerodim(zerodim_ideal)
end

#------------------------------------------------------------------------------
"""
    check_primality(polys::Dict{QQMPolyRingElem, QQMPolyRingElem})

The function checks if the ideal generated by the polynomials and saturated at
the leading coefficient with respect to the corresponding variables is prime
over rationals.
"""
function check_primality(polys::Dict{QQMPolyRingElem, QQMPolyRingElem})
    return check_primality(polys, Array{QQMPolyRingElem, 1}())
end

# ------------------------------------------------------------------------------
