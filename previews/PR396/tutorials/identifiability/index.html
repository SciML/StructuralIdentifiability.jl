<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Identifiability of Differential Models (Local and Global) · StructuralIdentifiability.jl</title><meta name="title" content="Identifiability of Differential Models (Local and Global) · StructuralIdentifiability.jl"/><meta property="og:title" content="Identifiability of Differential Models (Local and Global) · StructuralIdentifiability.jl"/><meta property="twitter:title" content="Identifiability of Differential Models (Local and Global) · StructuralIdentifiability.jl"/><meta name="description" content="Documentation for StructuralIdentifiability.jl."/><meta property="og:description" content="Documentation for StructuralIdentifiability.jl."/><meta property="twitter:description" content="Documentation for StructuralIdentifiability.jl."/><meta property="og:url" content="https://docs.sciml.ai/StructuralIdentifiability/stable/tutorials/identifiability/"/><meta property="twitter:url" content="https://docs.sciml.ai/StructuralIdentifiability/stable/tutorials/identifiability/"/><link rel="canonical" href="https://docs.sciml.ai/StructuralIdentifiability/stable/tutorials/identifiability/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StructuralIdentifiability.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StructuralIdentifiability.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../creating_ode/">Creating ODE System</a></li><li class="is-active"><a class="tocitem" href>Identifiability of Differential Models (Local and Global)</a><ul class="internal"><li><a class="tocitem" href="#Local-identifiability"><span>Local identifiability</span></a></li><li><a class="tocitem" href="#Global-identifiability"><span>Global identifiability</span></a></li><li><a class="tocitem" href="#Assuming-known-initial-conditions"><span>Assuming known initial conditions</span></a></li></ul></li><li><a class="tocitem" href="../identifiable_functions/">Globally Identifiable Functions</a></li><li><a class="tocitem" href="../discrete_time/">Identifiability of Discrete-Time Models (Local)</a></li><li><a class="tocitem" href="../reparametrization/">Reparametrizations</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../input/input/">Parsing input system</a></li><li><a class="tocitem" href="../../identifiability/identifiability/">Functions to Assess Identifiability</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../utils/local_identifiability/">Local Identifiability Tools</a></li><li><a class="tocitem" href="../../utils/global_identifiability/">Global Identifiability Tools</a></li><li><a class="tocitem" href="../../utils/elimination/">Elimination</a></li><li><a class="tocitem" href="../../utils/ode/">ODE Tools</a></li><li><a class="tocitem" href="../../utils/power_series_utils/">Power Series Tools</a></li><li><a class="tocitem" href="../../utils/primality/">Primality Checks</a></li><li><a class="tocitem" href="../../utils/wronskian/">Wronskian Tools</a></li><li><a class="tocitem" href="../../ioequations/ioequations/">Input-Output Equation tools</a></li><li><a class="tocitem" href="../../utils/util/">Other Utilities</a></li></ul></li><li><span class="tocitem">Export</span><ul><li><a class="tocitem" href="../../export/export/">Exporting to Other Systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Identifiability of Differential Models (Local and Global)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Identifiability of Differential Models (Local and Global)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/StructuralIdentifiability.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/StructuralIdentifiability.jl/blob/master/docs/src/tutorials/identifiability.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Identifiability-of-Differential-Models-(Local-and-Global)"><a class="docs-heading-anchor" href="#Identifiability-of-Differential-Models-(Local-and-Global)">Identifiability of Differential Models (Local and Global)</a><a id="Identifiability-of-Differential-Models-(Local-and-Global)-1"></a><a class="docs-heading-anchor-permalink" href="#Identifiability-of-Differential-Models-(Local-and-Global)" title="Permalink"></a></h1><p>Recall that we consider ODE models in the state-space form</p><p class="math-container">\[\begin{cases}
\mathbf{x}&#39;(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{p}, \mathbf{u}(t)),\\
\mathbf{y}(t) = \mathbf{g}(\mathbf{x}(t), \mathbf{p}, \mathbf{u(t)}),
\end{cases}\]</p><p>where <span>$\mathbf{x}(t), \mathbf{y}(t)$</span>, and <span>$\mathbf{u}(t)$</span> are time-dependent states, outputs, and inputs, respectively, and <span>$\mathbf{p}$</span> are scalar parameters. We will call that a parameter or a states (or a function of them) is <strong>identifiable</strong> if its value can be recovered from time series for inputs and outputs. Typically, two types of identifiability are distinguished</p><ul><li><p><strong>local</strong> identifiability: the value can be recovered up to finitely many options;</p></li><li><p><strong>global</strong> identifiability: the value can be recovered uniquely.</p></li></ul><p>Note that in the case of states, term <strong>observability</strong> it typically used. We will use <strong>identifiability</strong> for both states and parameters for brevity and uniformity. While the notion of global identifiability is much more precise, assessing local identifiability is typically much faster, and can be performed for the models whose global identifiability analysis is out of reach.</p><h2 id="Local-identifiability"><a class="docs-heading-anchor" href="#Local-identifiability">Local identifiability</a><a id="Local-identifiability-1"></a><a class="docs-heading-anchor-permalink" href="#Local-identifiability" title="Permalink"></a></h2><p>We consider the Lotka-Volterra model:</p><p class="math-container">\[\begin{cases}
x_1&#39;(t) = a x_1(t) - b x_1(t) x_2(t) + u(t),\\
x_2&#39;(t) = -c x_2(t) + d x_1(t) x_2(t),\\
y(t) = x_1(t)
\end{cases}\]</p><p>The local identifiability of all parameters and states in this model can be assessed as follows</p><pre><code class="language-julia hljs">using StructuralIdentifiability

ode = @ODEmodel(
    x1&#39;(t) = a * x1(t) - b * x1(t) * x2(t) + u(t),
    x2&#39;(t) = -c * x2(t) + d * x1(t) * x2(t),
    y(t) = x1(t)
)

assess_local_identifiability(ode)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Any, Bool} with 6 entries:
  x1(t) =&gt; 1
  x2(t) =&gt; 0
  a     =&gt; 1
  b     =&gt; 0
  c     =&gt; 1
  d     =&gt; 1</code></pre><p>We see that <span>$x_1(t)$</span> is locally identifiable (no surprises, this is an output), <span>$a, c,$</span> and <span>$d$</span> are identifiable as well. On the other hand, <span>$x_2(t)$</span> and <span>$b$</span> are nonidentifiable. This can be explained by the following scaling symmetry</p><p class="math-container">\[x_2(t) \to \lambda x_2(t), \quad b \to \frac{b}{\lambda}\]</p><p>which preserves input and output for every nonzero <span>$\lambda$</span>. The algorithm behind this call is the one due to Sedoglavic<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p>Function <code>assess_local_identifiability</code> has several optional parameters</p><ul><li><p><code>funcs_to_check</code> a list of specific functions of parameters and states to check identifiability for (see an example below). If not provided, the identifiability is assessed for all parameters and states.</p></li><li><p><code>prob_threshold</code> (default <code>0.99</code>, i.e. 99%) is the probability of correctness. The algorithm can, in theory, produce wrong result, but the probability that it is correct is guaranteed to be at least <code>prob_threshold</code>. However, the probability bounds we use are quite conservative, so the actual probability of correctness is likely to be much higher.</p></li><li><p><code>type</code> (default <code>:SE</code>). By default, the algorithm checks the standard single-experiment identifiability. If one sets <code>type = :ME</code>, then the algorithm checks multi-experiment identifiability, that is, identifiability from several experiments with independent initial conditions (the algorithm from <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> is used).</p></li><li><p><code>loglevel</code> (default <code>Logging.Info</code>). The minimal level of logging messages to be displayed. Available options: <code>Logging.Debug</code>, <code>Logging.Info</code>, <code>Logging.Warn</code>, and <code>Logging.Error</code>.</p></li></ul><p>Note that the scaling symmetry given above suggests that <span>$b x_2(t)$</span> may in fact be identifiable. This can be checked using <code>funcs_to_check</code> parameter:</p><pre><code class="language-julia hljs">assess_local_identifiability(ode, funcs_to_check = [b * x2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Any, Bool} with 1 entry:
  x2(t)*b =&gt; 1</code></pre><p>Indeed!</p><h2 id="Global-identifiability"><a class="docs-heading-anchor" href="#Global-identifiability">Global identifiability</a><a id="Global-identifiability-1"></a><a class="docs-heading-anchor-permalink" href="#Global-identifiability" title="Permalink"></a></h2><p>One can obtain more refined information about a model using <code>assess_identifiability</code> function. We will showcase it using the Goodwin oscillator model <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><pre><code class="language-julia hljs">using StructuralIdentifiability

ode = @ODEmodel(
    x1&#39;(t) = -b * x1(t) + 1 / (c + x4(t)),
    x2&#39;(t) = alpha * x1(t) - beta * x2(t),
    x3&#39;(t) = gama * x2(t) - delta * x3(t),
    x4&#39;(t) = sigma * x4(t) * (gama * x2(t) - delta * x3(t)) / x3(t),
    y(t) = x1(t)
)

assess_identifiability(ode)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Any, Symbol} with 11 entries:
  x1(t) =&gt; :globally
  x2(t) =&gt; :nonidentifiable
  x3(t) =&gt; :nonidentifiable
  x4(t) =&gt; :globally
  alpha =&gt; :nonidentifiable
  b     =&gt; :globally
  beta  =&gt; :locally
  c     =&gt; :globally
  delta =&gt; :locally
  gama  =&gt; :nonidentifiable
  sigma =&gt; :globally</code></pre><p>As a result, each parameter/state is assigned one of the labels <code>:globally</code> (globally identifiable), <code>:locally</code> (locally but not globally identifiable), or <code>:nonidentifiable</code> (not identifiable, even locally). The algorithm behind this computation follows <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>.</p><p>Similarly to <code>assess_local_identifiability</code>, this function has optional parameters:</p><ul><li><p><code>funcs_to_check</code> a list of specific functions of parameters and states to check identifiability for (see an example below). If not provided, the identifiability is assessed for all parameters and states. Note that the computations for states may be more involved than for the parameters, so one may want to call the function with <code>funcs_to_check = ode.parameters</code> if the call <code>assess_identifiability(ode)</code> takes too long.</p></li><li><p><code>prob_threshold</code> (default <code>0.99</code>, i.e. 99%) is the probability of correctness. Same story as above: the probability estimates are very conservative, so the actual error probability is much lower than 1%. Also, currently, the probability of correctness does not include the probability of correctness of the modular reconstruction for Groebner bases. This probability is ensured by an additional check modulo a large prime, and can be neglected for practical purposes.</p></li><li><p><code>loglevel</code> (default <code>Logging.Info</code>). The minimal level of logging messages to be displayed. Available options: <code>Logging.Debug</code>, <code>Logging.Info</code>, <code>Logging.Warn</code>, and <code>Logging.Error</code>.</p></li></ul><p>Using <code>funcs_to_check</code> parameter, one can further inverstigate the nature of the lack of identifiability in the model at hand. For example, for the Goodwin oscillator, we can check if <code>beta + delta</code> and <code>beta * delta</code> are identifiable:</p><pre><code class="language-julia hljs">assess_identifiability(ode, funcs_to_check = [beta + delta, beta * delta])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Any, Symbol} with 2 entries:
  beta + delta =&gt; :globally
  beta*delta   =&gt; :globally</code></pre><p>And we see that they indeed are. This means, in particular, that the reason why <code>beta</code> and <code>delta</code> are not identifiable is because their values can be exchanged. One may wonder how could we guess these functions <code>beta + delta, beta * delta</code>. In fact, they can be just computed using <code>find_identifiable_functions</code> function as we will explain in the next tutorial. Stay tuned!</p><h2 id="Assuming-known-initial-conditions"><a class="docs-heading-anchor" href="#Assuming-known-initial-conditions">Assuming known initial conditions</a><a id="Assuming-known-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Assuming-known-initial-conditions" title="Permalink"></a></h2><p>An experimental feature allows to provide an additional keyword argument <code>known_ic</code> to inidcate functions of states and parameters for which the initial conditions are assumed to be known (while the initial conditions of the system are still assumed to be generic). In this case, the identifiability will be assessed for parameters and all the initial conditions or for the initial conditions of <code>funcs_to_check</code>. Let us add an assumption that the initial conditions <span>$x_2(0)$</span> and <span>$x_3(0)$</span> are known:</p><pre><code class="language-julia hljs">assess_identifiability(ode, known_ic = [x2, x3])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{Nemo.QQMPolyRingElem, Symbol} with 11 entries:
  x1(0) =&gt; :globally
  x2(0) =&gt; :globally
  x3(0) =&gt; :globally
  x4(0) =&gt; :globally
  alpha =&gt; :locally
  b     =&gt; :globally
  beta  =&gt; :locally
  c     =&gt; :globally
  delta =&gt; :locally
  gama  =&gt; :locally
  sigma =&gt; :globally</code></pre><p>And we see that now <code>alpha</code> and <code>gama</code> become locally identifiable.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><blockquote><p>A. Sedoglavic, <a href="https://doi.org/10.1006/jsco.2002.0532"><em>A probabilistic algorithm to test local algebraic observability in polynomial time</em></a>, Journal of Symbolic Computation, 2002.</p></blockquote></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><blockquote><p>A. Ovchinnikov, A. Pillay, G. Pogudin, T. Scanlon, <a href="https://doi.org/10.1137/21M1389845"><em>Multi-experiment Parameter Identifiability of ODEs and Model Theory</em></a>, SIAM Journal on Applied Algebra and Geometry, 2022.</p></blockquote></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><blockquote><p>D. Gonze, P. Ruoff, <a href="https://doi.org/10.1007/s10441-020-09379-8"><em>The Goodwin Oscillator and its Legacy</em></a>, Acta Biotheoretica, 2020.</p></blockquote></li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><blockquote><p>R. Dong, C. Goodbrake, H. Harrington, G. Pogudin, <a href="https://doi.org/10.1137/22M1469067"><em>Differential elimination for dynamical models via projections with applications to structural identifiability</em></a>, SIAM Journal on Applied Algebra and Geometry, 2023.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../creating_ode/">« Creating ODE System</a><a class="docs-footer-nextpage" href="../identifiable_functions/">Globally Identifiable Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 17 March 2025 22:18">Monday 17 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
