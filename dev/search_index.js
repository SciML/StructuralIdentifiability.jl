var documenterSearchIndex = {"docs":
[{"location":"utils/ode/#Working-with-ODEs","page":"ODE Tools","title":"Working with ODEs","text":"","category":"section"},{"location":"utils/ode/","page":"ODE Tools","title":"ODE Tools","text":"Pages = [\"ode.md\"]","category":"page"},{"location":"utils/ode/","page":"ODE Tools","title":"ODE Tools","text":"Modules = [StructuralIdentifiability]\nPages   = [\"ODE.jl\", \"submodels.jl\"]","category":"page"},{"location":"utils/ode/#StructuralIdentifiability.PreprocessODE-Tuple{ModelingToolkit.ODESystem, Array{Symbolics.Equation}}","page":"ODE Tools","title":"StructuralIdentifiability.PreprocessODE","text":"function PreprocessODE(de::ModelingToolkit.ODESystem, measured_quantities::Array{ModelingToolkit.Equation})\n\nInput:\n\nde - ModelingToolkit.ODESystem, a system for identifiability query\nmeasured_quantities - array of output functions\n\nOutput:\n\nODE object containing required data for identifiability assessment\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability._reduce_mod_p-Tuple{Nemo.QQMPolyRingElem, Int64}","page":"ODE Tools","title":"StructuralIdentifiability._reduce_mod_p","text":"_reduce_mod_p(f, p)\n\nReduces a polynomial/rational function over Q modulo p\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.power_series_solution-Union{Tuple{P}, Tuple{T}, Tuple{ODE{P}, Dict{P, T}, Dict{P, T}, Dict{P, Vector{T}}, Int64}} where {T<:AbstractAlgebra.FieldElem, P<:AbstractAlgebra.MPolyRingElem{T}}","page":"ODE Tools","title":"StructuralIdentifiability.power_series_solution","text":"power_series_solution(ode, param_values, initial_conditions, input_values, prec)\n\nInput:\n\node - an ode to solve\nparam_values - parameter values, must be a dictionary mapping parameter to a value\ninitial_conditions - initial conditions of ode, must be a dictionary mapping state variable to a value\ninput_values - power series for the inputs presented as a dictionary variable => list of coefficients\nprec - the precision of solutions\n\nOutput:\n\ncomputes a power series solution with precision prec presented as a dictionary variable => corresponding coordinate of the solution\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.reduce_ode_mod_p-Tuple{ODE{<:AbstractAlgebra.MPolyRingElem{Nemo.QQFieldElem}}, Int64}","page":"ODE Tools","title":"StructuralIdentifiability.reduce_ode_mod_p","text":"reduce_ode_mod_p(ode, p)\n\nInput: ode is an ODE over QQ, p is a prime number Output: the reduction mod p, throws an exception if p divides one of the denominators\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.set_parameter_values-Union{Tuple{P}, Tuple{T}, Tuple{ODE{P}, Dict{P, T}}} where {T<:AbstractAlgebra.FieldElem, P<:AbstractAlgebra.MPolyRingElem{T}}","page":"ODE Tools","title":"StructuralIdentifiability.set_parameter_values","text":"set_parameter_values(ode, param_values)\n\nInput:\n\node - an ODE as above\nparam_values - values for (possibly, some of) the parameters as dictionary parameter => value\n\nOutput:\n\nnew ode with the parameters in param_values plugged with the given numbers\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.find_submodels-Union{Tuple{ODE{P}}, Tuple{P}} where P<:AbstractAlgebra.MPolyRingElem","page":"ODE Tools","title":"StructuralIdentifiability.find_submodels","text":"find_submodels(ode)\n\nThe function calculates and returns all valid submodels given a system of ODEs.\n\nInput:\n\node - an ODEs system to be studied\n\nOutput: \n\nA list of submodels represented as ode objects\n\nExample:\n\n>ode = @ODEmodel(x1'(t) = x1(t)^2, \n                 x2'(t) = x1(t) * x2(t), \n                 y1(t) = x1(t), \n                 y2(t) = x2(t))\n>find_submodels(ode)\n    ODE{fmpq_mpoly}[\n        \n        x1'(t) = a(t)*x2(t)^2 + x1(t)\n        y1(t) = x1(t)\n    ]\n\n\n\n\n\n","category":"method"},{"location":"utils/primality/#Primality-Checks","page":"Primality Chekcs","title":"Primality Checks","text":"","category":"section"},{"location":"utils/primality/","page":"Primality Chekcs","title":"Primality Chekcs","text":"Pages=[\"primality.md\"]","category":"page"},{"location":"utils/primality/","page":"Primality Chekcs","title":"Primality Chekcs","text":"StructuralIdentifiability.check_primality","category":"page"},{"location":"utils/primality/#StructuralIdentifiability.check_primality","page":"Primality Chekcs","title":"StructuralIdentifiability.check_primality","text":"check_primality(polys::Dict{fmpq_mpoly, fmpq_mpoly}, extra_relations::Array{fmpq_mpoly, 1})\n\nThe function checks if the ideal generated by the polynomials and saturated at the leading coefficient with respect to the corresponding variables is prime over rationals.\n\nThe extra_relations allows adding more polynomials to the generators (not affecting the saturation).\n\n\n\n\n\ncheck_primality(polys::Dict{fmpq_mpoly, fmpq_mpoly})\n\nThe function checks if the ideal generated by the polynomials and saturated at the leading coefficient with respect to the corresponding variables is prime over rationals.\n\n\n\n\n\n","category":"function"},{"location":"export/export/#Exporting-to-Other-Systems","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"","category":"section"},{"location":"export/export/","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"Here we put some helpful utilities to export your code to other identifiability software.","category":"page"},{"location":"export/export/","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"print_for_maple\nprint_for_DAISY\nprint_for_GenSSI\nprint_for_COMBOS","category":"page"},{"location":"export/export/#StructuralIdentifiability.print_for_maple","page":"Exporting to Other Systems","title":"StructuralIdentifiability.print_for_maple","text":"print_for_maple(ode, package)\n\nPrints the ODE in the format accepted by maple packages\n\nSIAN (https://github.com/pogudingleb/SIAN) if package=:SIAN\nDifferentialAlgebra if package=:DifferentialAlgebra\nDifferentialThomas if package=:DifferentialThomas\n\n\n\n\n\n","category":"function"},{"location":"export/export/#StructuralIdentifiability.print_for_DAISY","page":"Exporting to Other Systems","title":"StructuralIdentifiability.print_for_DAISY","text":"print_for_DAISY(ode)\n\nPrints the ODE in the format accepted by DAISY (https://daisy.dei.unipd.it/)\n\n\n\n\n\n","category":"function"},{"location":"export/export/#StructuralIdentifiability.print_for_GenSSI","page":"Exporting to Other Systems","title":"StructuralIdentifiability.print_for_GenSSI","text":"print_for_GenSSI(ode)\n\nPrints the ODE in the format accepted by GenSSI 2.0 (https://github.com/genssi-developer/GenSSI)\n\n\n\n\n\n","category":"function"},{"location":"export/export/#StructuralIdentifiability.print_for_COMBOS","page":"Exporting to Other Systems","title":"StructuralIdentifiability.print_for_COMBOS","text":"print_for_COMBOS(ode)\n\nPrints the ODE in the format accepted by COMBOS (http://biocyb1.cs.ucla.edu/combos/)\n\n\n\n\n\n","category":"function"},{"location":"utils/util/#Other-Helpful-Functions","page":"Other Utilities","title":"Other Helpful Functions","text":"","category":"section"},{"location":"utils/util/","page":"Other Utilities","title":"Other Utilities","text":"Pages=[\"util.md\"]","category":"page"},{"location":"utils/util/","page":"Other Utilities","title":"Other Utilities","text":"Modules = [StructuralIdentifiability]\nPages   = [\"util.jl\"]","category":"page"},{"location":"utils/util/#StructuralIdentifiability.decompose_derivative-Tuple{String, Array{String}}","page":"Other Utilities","title":"StructuralIdentifiability.decompose_derivative","text":"decompose_derivative(varname, prefixes)\n\nDetermines if it is possible to represent the varname as a_number where a is an element of prefixes\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.eval_at_dict-Union{Tuple{P}, Tuple{P, Dict{P, <:AbstractAlgebra.RingElem}}} where P<:AbstractAlgebra.MPolyRingElem","page":"Other Utilities","title":"StructuralIdentifiability.eval_at_dict","text":"eval_at_dict(f, d)\n\nEvaluates a polynomial/rational function on a dictionary of type var => val and missing values are replaced with zeroes\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.extract_coefficients-Union{Tuple{P}, Tuple{P, Vector{P}}} where P<:AbstractAlgebra.MPolyRingElem","page":"Other Utilities","title":"StructuralIdentifiability.extract_coefficients","text":"extract_coefficients(poly, variables)\n\nInput:\n\npoly - multivariate polynomial\nvariables - a list of variables from the generators of the ring of p\n\nOutput:\n\ndictionary with keys being tuples of length lenght(variables) and values being polynomials in the variables other than those which are the coefficients at the corresponding monomials (in a smaller polynomial ring)\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.make_substitution-Union{Tuple{P}, NTuple{4, P}} where P<:AbstractAlgebra.MPolyRingElem","page":"Other Utilities","title":"StructuralIdentifiability.make_substitution","text":"make_substitution(f, var_sub, val_numer, val_denom)\n\nSubstitute a variable in a polynomial with an expression\n\nInput:\n\nf - the polynomial\nvar_sub - the variable to be substituted\nvar_numer - numerator of the substitution expression\nvar_denom - denominator of the substitution expression\n\nOutput:\n\npolynomial - result of substitution\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.parent_ring_change-Tuple{AbstractAlgebra.MPolyRingElem, AbstractAlgebra.MPolyRing}","page":"Other Utilities","title":"StructuralIdentifiability.parent_ring_change","text":"parent_ring_change(poly, new_ring)\n\nConverts a polynomial to a different polynomial ring Input\n\npoly - a polynomial to be converted\nnew_ring - a polynomial ring such that every variable name appearing in poly appears among the generators\n\nOutput:\n\na polynomial in new_ring “equal” to poly\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.switch_ring-Tuple{AbstractAlgebra.MPolyRingElem, AbstractAlgebra.MPolyRing}","page":"Other Utilities","title":"StructuralIdentifiability.switch_ring","text":"switch_ring(v, ring)\n\nFor a variable v, returns a variable in ring with the same name\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.uncertain_factorization-Tuple{AbstractAlgebra.MPolyRingElem{Nemo.QQFieldElem}}","page":"Other Utilities","title":"StructuralIdentifiability.uncertain_factorization","text":"uncertain_factorization(f)\n\nInput:\n\nf - polynomial with rational coefficients\n\nOutput:\n\nlist of pairs (div, certainty) where\ndiv's are divisors of f such that f is their product with certain powers\nif certainty is true, div is Q-irreducible\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#Wronskian-Tools","page":"Wronskian Tools","title":"Wronskian Tools","text":"","category":"section"},{"location":"utils/wronskian/","page":"Wronskian Tools","title":"Wronskian Tools","text":"Modules = [StructuralIdentifiability]\nPages   = [\"wronskian.jl\"]","category":"page"},{"location":"utils/wronskian/#StructuralIdentifiability.get_max_below-Tuple{StructuralIdentifiability.ExpVectTrie, Vector{Int64}}","page":"Wronskian Tools","title":"StructuralIdentifiability.get_max_below","text":"get_max_below(t, vect)\n\nInput:\n\nt - a trie with exponent vectors\nvect - yet another exponent vector\n\nOutput:\n\na pair (d, v) where v is a vector in the trie which is componentwise ≤ vect and the difference d is as small as possible\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#StructuralIdentifiability.massive_eval-Tuple{Any, Any}","page":"Wronskian Tools","title":"StructuralIdentifiability.massive_eval","text":"massive_eval(polys, eval_dict)\n\nInput:\n\npolys - a list of polynomials\neval_dict - dictionary from variables to the values. Missing values are treated as zeroes\n\nOutput:\n\na list of values of the polynomials\n\nEvaluates a list of polynomials at a point. Assumes that multiplications are relatively expensive (like in truncated power series) so all the monomials are precomputed first and the values of monomials of lower degree are cached and used to compute the values of the monomials of higher degree\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#StructuralIdentifiability.monomial_compress-Tuple{Any, ODE}","page":"Wronskian Tools","title":"StructuralIdentifiability.monomial_compress","text":"monomial_compress(io_equation, ode)\n\nCompresses an input-output equation for the rank computation Input:\n\nio_equation - input-output equation\node - the corresponding ODE model\n\nOutput:\n\npair (coeffs, terms) such that:\nsum of coeffs[i] * terms[i] = io_equation\ncoeffs involve only parameters, terms involve only inputs and outputs\nlength of the representation is the smallest possible\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#StructuralIdentifiability.wronskian-Union{Tuple{P}, Tuple{Dict{P, P}, ODE{P}}} where P<:AbstractAlgebra.MPolyRingElem","page":"Wronskian Tools","title":"StructuralIdentifiability.wronskian","text":"wronskian(io_equations, ode)\n\nInput:\n\nio_equations - a set of io-equations in the form of the Dict as returned by find_ioequations\node - the ODE object\n\nOutput:\n\na list of Wronskians evaluated at a point modulo prime\n\nComputes the Wronskians of io_equations\n\n\n\n\n\n","category":"method"},{"location":"utils/global_identifiability/#Global-Identifiability-Tools","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"","category":"section"},{"location":"utils/global_identifiability/","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"Pages=[\"global_identifiability.md\"]","category":"page"},{"location":"utils/global_identifiability/","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"CurrentModule=StructuralIdentifiability","category":"page"},{"location":"utils/global_identifiability/","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"StructuralIdentifiability.extract_identifiable_functions\nStructuralIdentifiability.check_field_membership\nStructuralIdentifiability.find_identifiable_functions\nStructuralIdentifiability.get_degree_and_coeffsize","category":"page"},{"location":"utils/global_identifiability/#StructuralIdentifiability.extract_identifiable_functions","page":"Global Identifiability Tools","title":"StructuralIdentifiability.extract_identifiable_functions","text":"extract_identifiable_functions(io_equations, parameters)\n\nFor the io_equation and the list of all parameter variables, returns a set of generators of a field of all functions of parameters\n\nNote: an experimental functionality at the moment, may fail and may be inefficient\n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.check_field_membership","page":"Global Identifiability Tools","title":"StructuralIdentifiability.check_field_membership","text":"check_field_membership(generators, rat_funcs, p, [method=:GroebnerBasis])\n\nChecks whether given rational function belong to a given field of rational functions\n\nInputs:\n\ngenerators - a list of lists of polynomials. Each of the lists, say, [f1, ..., fn], defines generators f2/f1, ..., fn/f1. Let F be the field generated by all of them.\nrat_funcs - list of rational functions\np - a real number between 0 and 1, the probability of correctness\n\nOutput:\n\na list L[i] of bools of length length(rat_funcs) such that L[i] is true iff  the i-th function belongs to F. The whole result is correct with probability at least p\n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.find_identifiable_functions","page":"Global Identifiability Tools","title":"StructuralIdentifiability.find_identifiable_functions","text":"find_identifiable_functions(ode::ODE{<: MPolyElem{fmpq}}, p::Float64=0.99)\n\nInput:\n\node - ODE-system\np - probability of correctness\n\nOutput:\n\nreturns a set of generators of the field of all functions of parameters\n\nFind identifiable functions of parameters for a given ode.\n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.get_degree_and_coeffsize","page":"Global Identifiability Tools","title":"StructuralIdentifiability.get_degree_and_coeffsize","text":"get_degree_and_coeffsize(f)\n\nfor f being a polynomial/rational function over rationals (QQ) returns a tuple (degree, max_coef_size)\n\n\n\n\n\n","category":"function"},{"location":"utils/power_series_utils/#Power-Series-Utilities","page":"Power Series Tools","title":"Power Series Utilities","text":"","category":"section"},{"location":"utils/power_series_utils/","page":"Power Series Tools","title":"Power Series Tools","text":"Pages =[\"power_series_utils.md\"]","category":"page"},{"location":"utils/power_series_utils/","page":"Power Series Tools","title":"Power Series Tools","text":"Modules = [StructuralIdentifiability]\nPages   = [\"power_series_utils.jl\"]","category":"page"},{"location":"utils/power_series_utils/#StructuralIdentifiability._matrix_inv_newton_iteration-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}}} where T<:(AbstractAlgebra.AbsPowerSeriesRingElem{<:AbstractAlgebra.FieldElem})","page":"Power Series Tools","title":"StructuralIdentifiability._matrix_inv_newton_iteration","text":"_matrix_inv_newton_iteration(M, Minv)\n\nPerforms a single step of Newton iteration for inverting M with Minv being a partial result\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_diff-Tuple{AbstractAlgebra.AbsPowerSeriesRingElem{<:AbstractAlgebra.RingElem}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_diff","text":"ps_diff(ps)\n\nInput:\n\nps - (absolute capped) univariate power series\n\nOutput:\n\nthe derivative of ps\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_integrate-Tuple{AbstractAlgebra.AbsPowerSeriesRingElem{<:AbstractAlgebra.FieldElem}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_integrate","text":"ps_integrate(ps)\n\nInput:\n\nps - (absolute capped) univariate power series\n\nOutput:\n\nthe integral of ps without constant term\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_homlinear_de-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{T}}, AbstractAlgebra.MatElem{<:T}}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{T}}, AbstractAlgebra.MatElem{<:T}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_homlinear_de","text":"ps_matrix_homlinear_de(A, Y0, prec)\n\nInput:\n\nA - a square matrix with entries in a univariate power series ring\nY0 - a square invertible matrix over the base field\n\nOutput:\n\nmatrix Y such that Y' = AY up to precision of A - 1 and Y(0) = Y0\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_inv","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_inv","text":"ps_matrix_inv(M, prec)\n\nInput:\n\nM - a square matrix with entries in a univariate power series ring     it is assumed that M(0) is invertible and all entries having the same precision\nprec - an integer, precision, if -1 then defaults to precision of M\n\nOutput:\n\nthe inverse of M computed up to prec\n\n\n\n\n\n","category":"function"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_linear_de-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{T}}, AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{T}}, AbstractAlgebra.MatElem{<:T}}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{T}}, AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{T}}, AbstractAlgebra.MatElem{<:T}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_linear_de","text":"ps_matrix_linear_de(A, B, Y0, prec)\n\nInput:\n\nA, B - square matrices with entries in a univariate power series ring\nY0 - a matrix over the base field with the rows number the same as A\n\nOutput:\n\nmatrix Y such that Y' = AY + B up to precision of A - 1 and Y(0) = Y0\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_log-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsPowerSeriesRingElem{<:AbstractAlgebra.FieldElem}}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_log","text":"ps_matrix_log(M)\n\nInput:\n\nM - a square matrix with entries in a univariate power series ring     it is assumed that M(0) is the identity\n\nOutput:\n\nthe natural log of M\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_ode_solution-Union{Tuple{P}, Tuple{T}, Tuple{Vector{P}, Dict{P, T}, Dict{P, Vector{T}}, Int64}} where {T<:AbstractAlgebra.FieldElem, P<:AbstractAlgebra.MPolyRingElem{T}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_ode_solution","text":"ps_ode_solution(equations, ic, inputs, prec)\n\nInput:\n\nequations - a system of the form A(x u mu)x - B(x u mu) = 0,               where A is a generically nonsingular square matrix. Assumption: A is nonzero at zero\nic - initial conditions for x's (dictionary)\ninputs - power series for inputs represented as arrays (dictionary)\nprec - precision of the solution\n\nOutput:\n\npower series solution of the system\n\n\n\n\n\n","category":"method"},{"location":"identifiability/identifiability/#Functions-to-Assess-Parameter-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/#Assessing-All-Types-of-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"Assessing All Types of Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"assess_identifiability","category":"page"},{"location":"identifiability/identifiability/#StructuralIdentifiability.assess_identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"StructuralIdentifiability.assess_identifiability","text":"assess_identifiability(ode::ODE{P}, p::Float64=0.99) where P <: MPolyElem{fmpq}\n\nInput:\n\node - the ODE model\np - probability of correctness.\n\nAssesses identifiability (both local and global) of a given ODE model (parameters detected automatically). The result is guaranteed to be correct with the probability at least p.\n\n\n\n\n\nassess_identifiability(ode, [funcs_to_check, p=0.99])\n\nInput:\n\node - the ODE model\np - probability of correctness.\n\nAssesses identifiability of a given ODE model. The result is guaranteed to be correct with the probability at least p.\n\nIf funcs_to_check are given, then the function will assess the identifiability of the provided functions and return a list of the same length with each element being one of :nonidentifiable, :locally, :globally.\n\nIf funcs_to_check are not given, the function will assess identifiability of the parameters, and the result will be a dictionary from the parameters to their identifiability properties (again, one of :nonidentifiable, :locally, :globally).\n\n\n\n\n\nassess_identifiability(ode::ModelingToolkit.ODESystem; measured_quantities=Array{ModelingToolkit.Equation}[], funcs_to_check=[], p = 0.99)\n\nInput:\n\node - the ModelingToolkit.ODESystem object that defines the model\nmeasured_quantities - the output functions of the model\nfuncs_to_check - functions of parameters for which to check the identifiability\np - probability of correctness.\n\nAssesses identifiability (both local and global) of a given ODE model (parameters detected automatically). The result is guaranteed to be correct with the probability at least p.\n\n\n\n\n\n","category":"function"},{"location":"identifiability/identifiability/#Assessing-Local-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"Assessing Local Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"assess_local_identifiability","category":"page"},{"location":"identifiability/identifiability/#StructuralIdentifiability.assess_local_identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"StructuralIdentifiability.assess_local_identifiability","text":"function assess_local_identifiability(ode::ModelingToolkit.ODESystem; measured_quantities=Array{ModelingToolkit.Equation}[], funcs_to_check=Array{}[], p::Float64=0.99, type=:SE)\n\nInput:\n\node - the ODESystem object from ModelingToolkit\nmeasured_quantities - the measurable outputs of the model\nfuncs_to_check - functions of parameters for which to check identifiability\np - probability of correctness\ntype - identifiability type (:SE for single-experiment, :ME for multi-experiment)\n\nOutput:\n\nfor type=:SE, the result is a dictionary from each parameter to boolean;\nfor type=:ME, the result is a tuple with the dictionary as in :SE case and array of number of experiments.\n\nThe function determines local identifiability of parameters in funcs_to_check or all possible parameters if funcs_to_check is empty\n\nThe result is correct with probability at least p.\n\ntype can be either :SE (single-experiment identifiability) or :ME (multi-experiment identifiability). The return value is a tuple consisting of the array of bools and the number of experiments to be performed.\n\n\n\n\n\nassess_local_identifiability(ode::ODE{P}, p::Float64 = 0.99, type=:SE) where P <: MPolyElem{Nemo.fmpq}\n\nInput:\n\node - the ODE model\np - probability of correctness\ntype - identifiability type (:SE for single-experiment, :ME for multi-experiment)\n\nOutput:\n\nfor type=:SE, the result is a dictionary from each parameter to boolean;\nfor type=:ME, the result is a tuple with the dictionary as in :SE case and array of number of experiments.\n\nThe main entry point for local identifiability checks. Call this function to automatically take care of local identifiability of all parameters and initial conditions. The result is correct with probability at least p.\n\ntype can be either :SE (single-experiment identifiability) or :ME (multi-experiment identifiability). The return value is a tuple consisting of the array of bools and the number of experiments to be performed.\n\n\n\n\n\nassess_local_identifiability(ode::ODE{P}, funcs_to_check::Array{<: Any, 1}, p::Float64=0.99, type=:SE) where P <: MPolyElem{Nemo.fmpq}\n\nChecks the local identifiability/observability of the functions in funcs_to_check. The result is correct with probability at least p.\n\nCall this function if you have a specific collection of parameters of which you would like to check local identifiability.\n\ntype can be either :SE (single-experiment identifiability) or :ME (multi-experiment identifiability). If the type is :ME, states are not allowed to appear in the funcs_to_check.\n\n\n\n\n\n","category":"function"},{"location":"identifiability/identifiability/#Assessing-Global-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"Assessing Global Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"assess_global_identifiability","category":"page"},{"location":"identifiability/identifiability/#StructuralIdentifiability.assess_global_identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"StructuralIdentifiability.assess_global_identifiability","text":"assess_global_identifiability(ode::ODE{P}, p::Float64=0.99; var_change=:default) where P <: MPolyElem{fmpq}\n\nInput:\n\node - the ODE model\nknown - a list of functions in states which are assumed to be known and generic\np - probability of correctness\nvar_change - a policy for variable change (:default, :yes, :no), affects only the runtime\n\nOutput:\n\na dictionary mapping each parameter to a boolean.\n\nChecks global identifiability for parameters of the model provided in ode. Call this function to check global identifiability of all parameters automatically.\n\n\n\n\n\nassess_global_identifiability(ode, [funcs_to_check, p=0.99, var_change=:default])\n\nInput:\n\node - the ODE model\nfuncs_to_check - rational functions in parameters\nknown - function in parameters that are assumed to be known and generic\np - probability of correctness\nvar_change - a policy for variable change (:default, :yes, :no),               affects only the runtime\n\nOutput:\n\narray of length length(funcs_to_check) with true/false values for global identifiability       or dictionary param => Bool if funcs_to_check are not given\n\nChecks global identifiability of functions of parameters specified in funcs_to_check.\n\n\n\n\n\n","category":"function"},{"location":"utils/elimination/#Elimination","page":"Elimination","title":"Elimination","text":"","category":"section"},{"location":"utils/elimination/","page":"Elimination","title":"Elimination","text":"Pages=[\"elimination.md\"]","category":"page"},{"location":"utils/elimination/","page":"Elimination","title":"Elimination","text":"Modules = [StructuralIdentifiability]\nPages   = [\"elimination.jl\"]","category":"page"},{"location":"utils/elimination/#StructuralIdentifiability.Bezout_matrix-Union{Tuple{P}, Tuple{P, P, P}} where P<:AbstractAlgebra.MPolyRingElem","page":"Elimination","title":"StructuralIdentifiability.Bezout_matrix","text":"Bezout_matrix(f, g, var_elim)\n\nCompute the Bezout matrix of two polynomials f, g with respect to var_elim\n\nInputs:\n\nf - first polynomial\ng - second polynomial\nvar_elim - variable, of which f and g are considered as polynomials\n\nOutput:\n\nM::MatrixElem - The Bezout matrix\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.Sylvester_matrix-Union{Tuple{P}, Tuple{P, P, P}} where P<:AbstractAlgebra.MPolyRingElem","page":"Elimination","title":"StructuralIdentifiability.Sylvester_matrix","text":"Sylvester_matrix(f, g, var_elim)\n\nCompute the Sylvester matrix of two polynomials f, g with respect to var_elim Inputs:\n\nf - first polynomial\ng - second polynomial\nvar_elim - variable, of which f and g are considered as polynomials\n\nOutput:\n\nM::MatrixElem - The Sylvester matrix\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.choose-Union{Tuple{P}, Tuple{Vector{P}, Any}} where P<:(AbstractAlgebra.MPolyRingElem{<:AbstractAlgebra.FieldElem})","page":"Elimination","title":"StructuralIdentifiability.choose","text":"choose(polys, generic_point_generator)\n\nInput:\n\npolys - an array of distinct irreducible polynomials in the same ring\ngeneric_point_generator - a generic point generator as described above for one of polys\n\nOutput:\n\nthe polynomial that vanishes at the generic_point_generator\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.eliminate_var-Union{Tuple{P}, Tuple{P, P, P, Any}} where P<:(AbstractAlgebra.MPolyRingElem{<:AbstractAlgebra.FieldElem})","page":"Elimination","title":"StructuralIdentifiability.eliminate_var","text":"eliminate_var(f, g, var_elim, generic_point_generator)\n\nEliminate a variable from a pair of polynomials\n\nInput:\n\nf and g - polynomials\nvar_elim - variable to be eliminated\ngeneric_point_generator - a generic point generator object for the factor     of the resultant of f and g of interest\n\nOutput:\n\npolynomial - the desired factor of the resultant of f and g\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.simplify_matrix-Union{Tuple{AbstractAlgebra.MatElem{P}}, Tuple{P}} where P<:AbstractAlgebra.MPolyRingElem","page":"Elimination","title":"StructuralIdentifiability.simplify_matrix","text":"simplify_matrix(M)\n\nEliminate GCD of entries of every row and column\n\nInput:\n\nM::MatrixElem - matrix to be simplified\n\nOutput:\n\nM::MatrixElem - Simplified matrix\nextra_factors::Vector{AbstractAlgebra.MPolyElem} - array of GCDs eliminated from M.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/global_identifiability/#Global-Identifiability-of-Differential-Models","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"","category":"section"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"In this tutorial, let us cover an example problem of querying the ODE for globally identifiable parameters.","category":"page"},{"location":"tutorials/global_identifiability/#Input-System","page":"Global Identifiability of Differential Models","title":"Input System","text":"","category":"section"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Let us consider the following four-dimensional model with two outputs:","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"begincasesx(t) = lm - d  x(t) - beta  x(t)  v(t)\ny(t) = beta  x(t)  v(t) - a  y(t)\nv(t) = k  y(t) - u  v(t)\nw(t) = c  x(t)  y(t)  w(t) - c  q  y(t)  w(t) - b  w(t)\nz(t) = c  q  y(t)  w(t) - h  z(t)\ny_1(t) = w(t)\ny_2(t) = z(t)endcases","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"This model describes HIV dynamics[1]. Let us run a global identifiability check on this model to get the result with probability of correctness being p=0.99. To do this, we will use assess_identifiability(ode, p) function.","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Global identifiability needs information about local identifiability first, hence the function we chose here will take care of that extra step for us.","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n    x'(t) = lm - d * x(t) - beta * x(t) * v(t),\n    y'(t) = beta * x(t) * v(t) - a * y(t),\n    v'(t) = k * y(t) - u * v(t),\n    w'(t) = c * x(t) * y(t) * w(t) - c * q * y(t) * w(t) - b * w(t),\n    z'(t) = c * q * y(t) * w(t) - h * z(t),\n    y1(t) = w(t),\n    y2(t) = z(t)\n)\nglobal_id = assess_identifiability(ode, 0.99)","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"We also note that it's usually inexpensive to obtain the result with higher probability of correctness. For example, taking p=0.9999 in the system above will result only in a slight slowdown.","category":"page"},{"location":"tutorials/global_identifiability/#Note-on-the-probability-of-correctness","page":"Global Identifiability of Differential Models","title":"Note on the probability of correctness","text":"","category":"section"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Currently, the probability of correctness does not include the probability of correctness of the modular reconstruction for Groebner bases. This probability is ensured by an additional check modulo a large prime, and can be neglected for practical purposes. However, in the future versions, we plan to eliminate this possible error.","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"[1]: D. Wodarz, M. Nowak, Specific therapy regimes could lead to long-term immunological control of HIV, PNAS December 7, 1999 96 (25) 14464-14469;","category":"page"},{"location":"tutorials/local_identifiability/#Local-Identifiability-of-Differential-Models","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"In this tutorial, we will go over an example of solving a local identifiability problem for a simple system of ordinary differential equations.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We will introduce how to use the input parsing in StructuralIdentifiability.jl and the local identifiability assessment functionality.","category":"page"},{"location":"tutorials/local_identifiability/#Input-System","page":"Local Identifiability of Differential Models","title":"Input System","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We will consider a simple two-species competition model","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"x_1 = k (1 - x_1 - x_2) x_2=r(1-x_1-x_2)","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"To make it a proper input for the algorithm, we add an output function y=x_1 that equals to the population density of species 1 at any time t.","category":"page"},{"location":"tutorials/local_identifiability/#Using-the-@ODEmodel-macro","page":"Local Identifiability of Differential Models","title":"Using the @ODEmodel macro","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"To parse the system of ordinary differential equations as above, we will use @ODEmodel macro. This is the easiest way to do so.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We have two state variables x1, x2 (population densities), two parameters k, r (intrinsic growth rates), and one output function y. Note that there must be (t) to indicate time-dependent functions.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"After using the macro, we use the assess_local_identifiability function for that. This function accepts the ODE model, the probability of correctness, and the type of identifiability we would like to inquire about.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n    x1'(t) = k * (1 - x1(t) - x2(t)),\n    x2'(t) = r * (1 - x1(t) - x2(t)),\n    y(t) = x1(t)\n)\n\nlocal_id = assess_local_identifiability(ode, 0.99)","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"The result shows that only the state variable's initial value x_1(0) is locally identifiable.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"Let us now add another output function y2(t):","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n    x1'(t) = k * (1 - x1(t) - x2(t)),\n    x2'(t) = r * (1 - x1(t) - x2(t)),\n    y1(t) = x1(t),\n    y2(t) = x2(t) # new output function!\n)\n\nlocal_id = assess_local_identifiability(ode, 0.99) # this is a different result!","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"As you can see, for this new model with an additional output, all parameters are reported as locally identifiable with probability 0.99.","category":"page"},{"location":"tutorials/local_identifiability/#Note-on-Probability-of-Correctness","page":"Local Identifiability of Differential Models","title":"Note on Probability of Correctness","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We set the probability of correctness p to be 0.99. Why would we ever want a lower value? Great question! The underlying algorithm relies on operations being modulo a large enough prime characteristic mathcalPgeq kappa p where kappa is determined by the algorithm internally.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"The algorithm's complexity is proportional to the size of operands (see proposition 3.1 in the main paper[1]) and high probability of correctness may thus lead to higher size of coefficients during computation for some systems. Hence, one may wish to lower p to save on runtime (though in practice this is very rare).","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"[1]: A. Sedoglavic, A probabilistic algorithm to test local algebraic observability in polynomial time, Journal of Symbolic Computation, 2002.","category":"page"},{"location":"tutorials/using_modeling_toolkit/#Using-ModelingToolkit.jl-With-StructuralIdentifiability.jl","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"","category":"section"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"In this tutorial, we will cover examples of solving identifiability problems for models defined with the syntax of ModelingToolkit.jl.","category":"page"},{"location":"tutorials/using_modeling_toolkit/#Input-System","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Input System","text":"","category":"section"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"Let us consider the following ODE model with two outputs:","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"begincases\ndotS = -b  S  (I + J + q  A)  N_inv\ndotE = b  S  (I + J + q  A)  N_inv - k  E\ndotA = k  (1 - r)  E - g_1  A\ndotI = k  r  E - (alpha + g_1)  I\ndotJ = alpha  I - g_2  J\ndotC = alpha  I\ny_1 = C\ny_2 = N_inv\nendcases","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"This is an infectious disease model defined in [1].","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"The main difference between the input formats in ModelingToolkit.jl and StructuralIdentifiability.jl is that the output (measured values/functions) must be specified separately in ModelingToolkit.jl. In this example, measured quantities are presented by y_1, y_2.","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"First, let us define the ODE. We will use @parameters and @variables macro to define parameters and time-depended functions in the ODE.","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"using StructuralIdentifiability, ModelingToolkit\n\n@parameters b q N_inv k r alpha g1 g2\n@variables t S(t) E(t) A(t) I(t) J(t) C(t) y1(t) y2(t)","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"The actual ODE will be defined using ODESystem structure from ModelingToolkit.jl:","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"D = Differential(t)\n\neqs = [\n    D(S) ~ -b * S * (I + J + q * A) * N_inv,\n    D(E) ~ b * S * (I + J + q * A) * N_inv - k * E,\n    D(A) ~ k * (1 - r) * E - g1 * A,\n    D(I) ~ k * r * E - (alpha + g1) * I,\n    D(J) ~ alpha * I - g2 * J,\n    D(C) ~ alpha * I,\n]\n\node = ODESystem(eqs, t, name = :SEIAJRCmodel)","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"Finally, let us define the array of measured quantities and call the assess_identifiability function. This is the main function that determines local/global identifiability properties of each parameter and state. We will use the probability of correctness p=099.","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"For ModelingToolkit.jl, both assess_identifiability and assess_local_identifiability functions accept keyword arguments:","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"measured_quantities, also called “output functions” in identifiability literature; these are crucial for answering identifiability questions.\np, probability of correctness. This value equals 0.99 by default.\nfuncs_to_check, functions of parameters of which we wish to check identifiability.","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"measured_quantities = [y1 ~ C, y2 ~ N_inv]\n@time global_id = assess_identifiability(ode, measured_quantities = measured_quantities)","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"Let us put all the code above together:","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"using StructuralIdentifiability, ModelingToolkit\n\n@parameters b q N_inv k r alpha g1 g2\n@variables t S(t) E(t) A(t) I(t) J(t) C(t) y1(t) y2(t)\n\nD = Differential(t)\n\neqs = [\n    D(S) ~ -b * S * (I + J + q * A) * N_inv,\n    D(E) ~ b * S * (I + J + q * A) * N_inv - k * E,\n    D(A) ~ k * (1 - r) * E - g1 * A,\n    D(I) ~ k * r * E - (alpha + g1) * I,\n    D(J) ~ alpha * I - g2 * J,\n    D(C) ~ alpha * I,\n]\n\node = ODESystem(eqs, t, name = :SEIAJRCmodel)\n\nmeasured_quantities = [y1 ~ C, y2 ~ N_inv]\n@time global_id = assess_identifiability(ode, measured_quantities = measured_quantities)","category":"page"},{"location":"tutorials/using_modeling_toolkit/","page":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","title":"Using ModelingToolkit.jl With StructuralIdentifiability.jl","text":"[1]: K. Roosa and G. Chowell. Assessing parameter identifiability in compartmental dynamic models using a computational approach: application to infectious disease transmission models, Theor Biol Med Model 16, 1 (2019)","category":"page"},{"location":"ioequations/ioequations/#Finding-Input-Output-Equations","page":"Input-Output Equation tools","title":"Finding Input-Output Equations","text":"","category":"section"},{"location":"ioequations/ioequations/","page":"Input-Output Equation tools","title":"Input-Output Equation tools","text":"find_ioequations","category":"page"},{"location":"ioequations/ioequations/#StructuralIdentifiability.find_ioequations","page":"Input-Output Equation tools","title":"StructuralIdentifiability.find_ioequations","text":"find_ioequations(ode, [var_change_policy=:default])\n\nFinds the input-output equations of an ODE system Input:\n\node - the ODE system\nvar_change_policy - whether to perform automatic variable change, can be one of :default, :yes, :no\n\nOutput:\n\na dictionary from “leaders” to the corresponding input-output equations\n\n\n\n\n\n","category":"function"},{"location":"ioequations/ioequations/#Reducing-with-respect-to-Input-Output-Equations","page":"Input-Output Equation tools","title":"Reducing with respect to Input-Output Equations","text":"","category":"section"},{"location":"ioequations/ioequations/","page":"Input-Output Equation tools","title":"Input-Output Equation tools","text":"PBRepresentation\npseudodivision\ndiffreduce\nio_switch!","category":"page"},{"location":"ioequations/ioequations/#StructuralIdentifiability.PBRepresentation","page":"Input-Output Equation tools","title":"StructuralIdentifiability.PBRepresentation","text":"The structure for storing a projection-based representation of differential ideal (see Section 2.3 https://arxiv.org/abs/2111.00991). Contains the following fields:\n\ny_names - the names of the variables with finite order in the profile (typically, outputs)\nu_names - the names of the variables with infinite order in the profile (typically, inputs)\nparam_names - the names of the parameters\nprofile - the profile of the PB-representation (see Definition 2.13) as a dict from y_names with finite orders to the orders\nprojections - the corresponding projections (see Definition 2.15) as a dict from y_names to the projections\n\n\n\n\n\n","category":"type"},{"location":"ioequations/ioequations/#StructuralIdentifiability.pseudodivision","page":"Input-Output Equation tools","title":"StructuralIdentifiability.pseudodivision","text":"pseudodivision(f, g, x)\n\nComputes the result of pseudodivision of f by g as univariate polynomials in x Input:\n\nf - the polynomial to be divided\ng - the polynomial to divide by\nx - the variable for the division\n\nOutput: the pseudoremainder of f divided by g w.r.t. x\n\n\n\n\n\n","category":"function"},{"location":"ioequations/ioequations/#StructuralIdentifiability.diffreduce","page":"Input-Output Equation tools","title":"StructuralIdentifiability.diffreduce","text":"diffreduce(diffpoly, pbr)\n\nComputes the result of differential reduction of a differential polynomial diffpoly with respect to the charset defined by a PB-representation pbr Input:\n\ndiffpoly - a polynomial representing a differential polynomial to be reduced\npbr - a projection-based representation\n\nOutput: the result of differential reduction of diffpoly by pbr considered as a characteristic set (see Remark 2.20 in the paper)\n\n\n\n\n\n","category":"function"},{"location":"ioequations/ioequations/#StructuralIdentifiability.io_switch!","page":"Input-Output Equation tools","title":"StructuralIdentifiability.io_switch!","text":"io_switch(pbr)\n\nIn a single-output pb-representation pbr makes the leading variable to be the first of the inputs\n\n\n\n\n\n","category":"function"},{"location":"utils/local_identifiability/#Local-Identifiability-Tools","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"","category":"section"},{"location":"utils/local_identifiability/","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"Pages=[\"local_identifiability.md\"]","category":"page"},{"location":"utils/local_identifiability/","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"CurrentModule=StructuralIdentifiability","category":"page"},{"location":"utils/local_identifiability/","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"StructuralIdentifiability.differentiate_solution\nStructuralIdentifiability.differentiate_output","category":"page"},{"location":"utils/local_identifiability/#StructuralIdentifiability.differentiate_solution","page":"Local Identifiability Tools","title":"StructuralIdentifiability.differentiate_solution","text":"differentiate_solution(ode, params, ic, inputs, prec)\n\nInput:\n\nthe same as for power_series_solutions\n\nOutput:\n\na tuple consisting of the power series solution and a dictionary of the form (u, v) => power series, where u is a state variable v is a state or parameter, and the power series is the partial derivative of the function u w.r.t. v evaluated at the solution\n\n\n\n\n\n","category":"function"},{"location":"utils/local_identifiability/#StructuralIdentifiability.differentiate_output","page":"Local Identifiability Tools","title":"StructuralIdentifiability.differentiate_output","text":"differentiate_output(ode, params, ic, inputs, prec)\n\nSimilar to differentiate_solution but computes partial derivatives of prescribed outputs returns a dictionary of the form y_function => Dict(var => dy/dvar) where dy/dvar is the derivative of y_function with respect to var.\n\n\n\n\n\n","category":"function"},{"location":"#StructuralIdentifiability.jl","page":"Home","title":"StructuralIdentifiability.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StructuralIdentifiability.jl is a comprehensive toolbox for assessing identifiability parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation contains information about the functionality of the package as well as examples of use cases.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install StructuralIdentifiability.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"StructuralIdentifiability\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@article{structidjl,\n  author  = {Dong, R. and Goodbrake, C. and Harrington, H. and Pogudin G.},\n  title   = {Differential Elimination for Dynamical Models via Projections with Applications to Structural Identifiability},\n  journal = {SIAM Journal on Applied Algebra and Geometry},\n  url     = {https://doi.org/10.1137/22M1469067},\n  year    = {2023}\n  volume  = {7},\n  number  = {1},\n  pages   = {194-235}\n}","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StructuralIdentifiability.jl can assess local and global identifiability of ODE models. In addition to these straightforward identifiability queries on individual parameters, the package can distinguish between single- and multi-experiment identifiability.","category":"page"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Local identifiability checks\nGlobal identifiability checks\nAssessment of identifiable functions of parameters","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to StructuralIdentifiability.\nThere are a few community forums:\nThe #diffeq-bridged channel in the Julia Slack\nJuliaDiffEq on Gitter\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink =\n    \"https://github.com/SciML/\" *\n    name *\n    \".jl/tree/gh-pages/v\" *\n    version *\n    \"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink =\n    \"https://github.com/SciML/\" *\n    name *\n    \".jl/tree/gh-pages/v\" *\n    version *\n    \"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"},{"location":"input/input/#Parsing-input-ODE-system","page":"Parsing input ODE system","title":"Parsing input ODE system","text":"","category":"section"},{"location":"input/input/","page":"Parsing input ODE system","title":"Parsing input ODE system","text":"@ODEmodel(ex::Expr...)\nODE\nset_parameter_values","category":"page"},{"location":"input/input/#StructuralIdentifiability.@ODEmodel-Tuple{Vararg{Expr}}","page":"Parsing input ODE system","title":"StructuralIdentifiability.@ODEmodel","text":"Macro for creating an ODE from a list of equations. Also injects all variables into the global scope.\n\nThis macro accepts a sybolically written ODE system and generates an ODE structure instance:\n\node = @ODEmodel(\n    x1'(t) = -k1 * x1(t),\n    y1(t) = x1(t)\n)\n\n\n\n\n\n","category":"macro"},{"location":"input/input/#StructuralIdentifiability.ODE","page":"Parsing input ODE system","title":"StructuralIdentifiability.ODE","text":"The main structure that represents input ODE system.\n\nStores information about states (x_vars), outputs (y_vars), inputs (u_vars), parameters (parameters) and the equations.\n\nThis structure is constructed via @ODEmodel macro.\n\n\n\n\n\n","category":"type"},{"location":"input/input/#StructuralIdentifiability.set_parameter_values","page":"Parsing input ODE system","title":"StructuralIdentifiability.set_parameter_values","text":"set_parameter_values(ode, param_values)\n\nInput:\n\node - an ODE as above\nparam_values - values for (possibly, some of) the parameters as dictionary parameter => value\n\nOutput:\n\nnew ode with the parameters in param_values plugged with the given numbers\n\n\n\n\n\n","category":"function"},{"location":"input/input/#Create-Compartmental-Model","page":"Parsing input ODE system","title":"Create Compartmental Model","text":"","category":"section"},{"location":"input/input/","page":"Parsing input ODE system","title":"Parsing input ODE system","text":"linear_compartment_model","category":"page"},{"location":"input/input/#StructuralIdentifiability.linear_compartment_model","page":"Parsing input ODE system","title":"StructuralIdentifiability.linear_compartment_model","text":"linear_compartment_model(graph, inputs, outputs, leaks)\n\nInput: defines a linear compartment model with nodes numbered from 1 to n by\n\ngraph - and array of integer arrays representing the adjacency lists of the graph\ninputs - array of input nodes\noutputs - array of output nodes\nleaks - array of sink nodes\n\nOutput:\n\nthe corresponding ODE system in the notation of https://doi.org/10.1007/s11538-015-0098-0\n\n\n\n\n\n","category":"function"}]
}
