var documenterSearchIndex = {"docs":
[{"location":"input/input/#Parsing-input-ODE-system","page":"Parsing input ODE system","title":"Parsing input ODE system","text":"","category":"section"},{"location":"input/input/","page":"Parsing input ODE system","title":"Parsing input ODE system","text":"@ODEmodel(ex::Expr...)\nODE\nset_parameter_values","category":"page"},{"location":"input/input/#StructuralIdentifiability.@ODEmodel-Tuple{Vararg{Expr}}","page":"Parsing input ODE system","title":"StructuralIdentifiability.@ODEmodel","text":"Macro for creating an ODE from a list of equations. Also injects all variables into the global scope.\n\nThis macro accepts a sybolically written ODE system and generates an ODE structure instance:\n\node = @ODEmodel(\n    x1'(t) = -k1 * x1(t),\n    y1(t) = x1(t)\n)\n\n\n\n\n\n","category":"macro"},{"location":"input/input/#StructuralIdentifiability.ODE","page":"Parsing input ODE system","title":"StructuralIdentifiability.ODE","text":"The main structure that represents input ODE system.\n\nStores information about states (x_vars), outputs (y_vars), inputs (u_vars), parameters (parameters) and the equations.\n\nThis structure is constructed via @ODEmodel macro.\n\n\n\n\n\n","category":"type"},{"location":"input/input/#StructuralIdentifiability.set_parameter_values","page":"Parsing input ODE system","title":"StructuralIdentifiability.set_parameter_values","text":"set_parameter_values(ode, param_values)\n\nInput:\n\node - an ODE as above\nparam_values - values for (possibly, some of) the parameters as dictionary parameter => value\n\nOutput: \n\nnew ode with the parameters in param_values plugged with the given numbers\n\n\n\n\n\n","category":"function"},{"location":"input/input/#Create-Compartmental-Model","page":"Parsing input ODE system","title":"Create Compartmental Model","text":"","category":"section"},{"location":"input/input/","page":"Parsing input ODE system","title":"Parsing input ODE system","text":"linear_compartment_model","category":"page"},{"location":"input/input/#StructuralIdentifiability.linear_compartment_model","page":"Parsing input ODE system","title":"StructuralIdentifiability.linear_compartment_model","text":"linear_compartment_model(graph, inputs, outputs, leaks)\n\nInput: defines a linear compartment model with nodes numbered from 1 to n by\n\ngraph - and array of integer arrays representing the adjacency lists of the graph\ninputs - array of input nodes\noutputs - array of output nodes\nleaks - array of sink nodes\n\nOutput:\n\nthe corresponding ODE system in the notation of https://doi.org/10.1007/s11538-015-0098-0\n\n\n\n\n\n","category":"function"},{"location":"utils/primality/#Primality-Checks","page":"Primality Chekcs","title":"Primality Checks","text":"","category":"section"},{"location":"utils/primality/","page":"Primality Chekcs","title":"Primality Chekcs","text":"Pages=[\"primality.md\"]","category":"page"},{"location":"utils/primality/","page":"Primality Chekcs","title":"Primality Chekcs","text":"StructuralIdentifiability.check_primality","category":"page"},{"location":"utils/primality/#StructuralIdentifiability.check_primality","page":"Primality Chekcs","title":"StructuralIdentifiability.check_primality","text":"check_primality(polys::Dict{fmpq_mpoly, fmpq_mpoly}, extra_relations::Array{fmpq_mpoly, 1})\n\nThe function checks if the ideal generated by the polynomials and saturated at the leading coefficient with respect to the corresponding variables is prime over rationals.\n\nThe extra_relations allows to add more polynomials to the generators (not affecting the saturation).\n\n\n\n\n\ncheck_primality(polys::Dict{fmpq_mpoly, fmpq_mpoly})\n\nThe function checks if the ideal generated by the polynomials and saturated at the leading coefficient with respect to the corresponding variables is prime over rationals.\n\n\n\n\n\n","category":"function"},{"location":"export/export/#Exporting-to-Other-Systems","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"","category":"section"},{"location":"export/export/","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"Here we put some helpful utilities to export you code to other identifiability software.","category":"page"},{"location":"export/export/#Maple","page":"Exporting to Other Systems","title":"Maple","text":"","category":"section"},{"location":"export/export/","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"print_for_maple","category":"page"},{"location":"export/export/#StructuralIdentifiability.print_for_maple","page":"Exporting to Other Systems","title":"StructuralIdentifiability.print_for_maple","text":"print_for_maple(ode, package)\n\nPrints the ODE in the format accepted by maple packages\n\nSIAN (https://github.com/pogudingleb/SIAN) if package=:SIAN\nDifferentialAlgebra if package=:DifferentialAlgebra\nDifferentialThomas if package=:DifferentialThomas\n\n\n\n\n\n","category":"function"},{"location":"export/export/#DAISY","page":"Exporting to Other Systems","title":"DAISY","text":"","category":"section"},{"location":"export/export/","page":"Exporting to Other Systems","title":"Exporting to Other Systems","text":"print_for_DAISY","category":"page"},{"location":"export/export/#StructuralIdentifiability.print_for_DAISY","page":"Exporting to Other Systems","title":"StructuralIdentifiability.print_for_DAISY","text":"print_for_DAISY(ode)\n\nPrints the ODE in the format accepted by DAISY (https://daisy.dei.unipd.it/)\n\n\n\n\n\n","category":"function"},{"location":"utils/util/#Other-Helpful-Functions","page":"Other Utilities","title":"Other Helpful Functions","text":"","category":"section"},{"location":"utils/util/","page":"Other Utilities","title":"Other Utilities","text":"Pages=[\"util.md\"]","category":"page"},{"location":"utils/util/","page":"Other Utilities","title":"Other Utilities","text":"Modules = [StructuralIdentifiability]\nPages   = [\"util.jl\"]","category":"page"},{"location":"utils/util/#StructuralIdentifiability.eval_at_dict-Union{Tuple{P}, Tuple{P, Dict{P, <:AbstractAlgebra.RingElem}}} where P<:AbstractAlgebra.MPolyElem","page":"Other Utilities","title":"StructuralIdentifiability.eval_at_dict","text":"eval_at_dict(f, d)\n\nEvaluates a polynomial/rational function on a dictionary of type var => val and missing values are replaced with zeroes\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.extract_coefficients-Union{Tuple{P}, Tuple{P, Vector{P}}} where P<:AbstractAlgebra.MPolyElem","page":"Other Utilities","title":"StructuralIdentifiability.extract_coefficients","text":"extract_coefficients(poly, variables)\n\nIntput:\n\npoly - multivariate polynomial\nvariables - a list of variables from the generators of the ring of p\n\nOutput:\n\ndictionary with keys being tuples of length lenght(variables) and values being polynomials in the variables other than those which are the coefficients at the corresponding monomials (in a smaller polynomial ring)\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.make_substitution-Union{Tuple{P}, NTuple{4, P}} where P<:AbstractAlgebra.MPolyElem","page":"Other Utilities","title":"StructuralIdentifiability.make_substitution","text":"make_substitution(f, var_sub, val_numer, val_denom)\n\nSubstitute a variable in a polynomial with an expression\n\nInput:\n\nf - the polynomial\nvar_sub - the variable to be substituted\nvar_numer - numerator of the substitution expression\nvar_denom - denominator of the substitution expression\n\nOutput:\n\npolynomial - result of substitution\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.parent_ring_change-Tuple{AbstractAlgebra.MPolyElem, AbstractAlgebra.MPolyRing}","page":"Other Utilities","title":"StructuralIdentifiability.parent_ring_change","text":"parent_ring_change(poly, new_ring)\n\nConverts a polynomial to a different polynomial ring Input\n\npoly - a polynomial to be converted\nnew_ring - a polynomial ring such that every variable name appearing in poly appears among the generators\n\nOutput:\n\na polynomial in new_ring \"equal\" to poly\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.switch_ring-Tuple{AbstractAlgebra.MPolyElem, AbstractAlgebra.MPolyRing}","page":"Other Utilities","title":"StructuralIdentifiability.switch_ring","text":"switch_ring(v, ring)\n\nFor a variable v, returns a variable in ring with the same name\n\n\n\n\n\n","category":"method"},{"location":"utils/util/#StructuralIdentifiability.uncertain_factorization-Tuple{AbstractAlgebra.MPolyElem{Nemo.fmpq}}","page":"Other Utilities","title":"StructuralIdentifiability.uncertain_factorization","text":"uncertain_factorization(f)\n\nInput:\n\nf - polynomial with rational coefficients\n\nOutput: \n\nlist of pairs (div, certainty) where\ndiv's are divisors of f such that f is their product with certain powers\nif certainty is true, div is Q-irreducible\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#Wronskian-Tools","page":"Wronskian Tools","title":"Wronskian Tools","text":"","category":"section"},{"location":"utils/wronskian/","page":"Wronskian Tools","title":"Wronskian Tools","text":"Modules = [StructuralIdentifiability]\nPages   = [\"wronskian.jl\"]","category":"page"},{"location":"utils/wronskian/#StructuralIdentifiability.get_max_below-Tuple{StructuralIdentifiability.ExpVectTrie, Vector{Int64}}","page":"Wronskian Tools","title":"StructuralIdentifiability.get_max_below","text":"get_max_below(t, vect)\n\nInput:\n\nt - a trie with exponent vectors\nvect - yet another exponent vector\n\nOutput: \n\na pair (d, v) where v is a vector in the trie which is componenwise ≤ vect and the difference d is as small as possible\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#StructuralIdentifiability.massive_eval-Tuple{Any, Any}","page":"Wronskian Tools","title":"StructuralIdentifiability.massive_eval","text":"massive_eval(polys, eval_dict)\n\nInput:\n\npolys - a list of polynomials\neval_dict - dictionary from variables to the values. Missing values are treated as zeroes\n\nOutput: \n\na list of values of the polynomials\n\nEvaluates a list of polynomails at a point. Assumes that multiplications are relatively expensive (like in truncated power series) so all the monomials are precomputed first and the values of monomials of lower degree are cached and used to compute the values of the monomials of higher degree\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#StructuralIdentifiability.monomial_compress-Tuple{Any, ODE}","page":"Wronskian Tools","title":"StructuralIdentifiability.monomial_compress","text":"monomial_compress(io_equation, ode)\n\nCompresses an input-output equation for the rank computation Input: \n\nio_equation - input-output equation\node - the corresponding ODE model\n\nOutput: \n\npair (coeffs, terms) such that:\nsum of coeffs[i] * terms[i] = io_equation\ncoeffs involve only parameters, terms involve only inputs and outputs\nlength of the representation is the smallest possible\n\n\n\n\n\n","category":"method"},{"location":"utils/wronskian/#StructuralIdentifiability.wronskian-Union{Tuple{P}, Tuple{Dict{P, P}, ODE{P}}} where P<:AbstractAlgebra.MPolyElem","page":"Wronskian Tools","title":"StructuralIdentifiability.wronskian","text":"wronskian(io_equations, ode)\n\nInput:\n\nio_equations - a set of io-equations in the form of the Dict as returned by find_ioequations\node - the ODE object\n\nOutput: \n\na list of wronskians evaluated at a point modulo prime\n\nComputes the wronskians of io_equations\n\n\n\n\n\n","category":"method"},{"location":"utils/global_identifiability/#Global-Identifiability-Tools","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"","category":"section"},{"location":"utils/global_identifiability/","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"Pages=[\"global_identifiability.md\"]","category":"page"},{"location":"utils/global_identifiability/","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"CurrentModule=StructuralIdentifiability","category":"page"},{"location":"utils/global_identifiability/","page":"Global Identifiability Tools","title":"Global Identifiability Tools","text":"StructuralIdentifiability.extract_identifiable_functions\nStructuralIdentifiability.check_field_membership\nStructuralIdentifiability.find_identifiable_functions\nStructuralIdentifiability.simplify_field_generators\nStructuralIdentifiability.get_degree_and_coeffsize","category":"page"},{"location":"utils/global_identifiability/#StructuralIdentifiability.extract_identifiable_functions","page":"Global Identifiability Tools","title":"StructuralIdentifiability.extract_identifiable_functions","text":"extract_identifiable_functions(io_equations, parameters)\n\nFor the io_equation and the list of all parameter variables, returns a set of generators of a field of all functions of parameters\n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.check_field_membership","page":"Global Identifiability Tools","title":"StructuralIdentifiability.check_field_membership","text":"check_field_membership(generators, rat_funcs, p, [method=:GroebnerBasis])\n\nChecks whether given rational function belogn to a given field of rational functions\n\nInputs:\n\ngenerators - a list of lists of polynomials. Each of the lists, say, [f1, ..., fn], defines generators f2/f1, ..., fn/f1. Let F be the field generated by all of them.\nrat_funcs - list rational functions\np - a real number between 0 and 1, the probability of correctness\n\nOutput: \n\na list L[i] of bools of length length(rat_funcs) such that L[i] is true iff  the i-th function belongs to F. The whole result is correct with probability at least p\n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.find_identifiable_functions","page":"Global Identifiability Tools","title":"StructuralIdentifiability.find_identifiable_functions","text":"find_identifiable_functions(ode::ODE{<: MPolyElem{fmpq}}, p::Float64=0.99)\n\nInput:\n\node - ODE-system\np - probability of correctness\n\nOutput:\n\nreturns a set of generators of the field of all functions of parameters\n\nFind identifiable functions of parameters for a given ode. \n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.simplify_field_generators","page":"Global Identifiability Tools","title":"StructuralIdentifiability.simplify_field_generators","text":"simplify_field_generators(generators)\n\nSimplifies generators of a subfield of rational functions Inputs:     - generators - a list of lists of polynomials. Each of the lists, say, [f1, ..., fn],       defines generators f2/f1, ..., fn/f1. Let F be the field generated by all of them. Output: simplified generators of F\n\n\n\n\n\n","category":"function"},{"location":"utils/global_identifiability/#StructuralIdentifiability.get_degree_and_coeffsize","page":"Global Identifiability Tools","title":"StructuralIdentifiability.get_degree_and_coeffsize","text":"get_degree_and_coeffsize(f)\n\nfor f being a polynomial/rational function over rationals (QQ) returns a tuple (degree, max_coef_size)\n\n\n\n\n\n","category":"function"},{"location":"utils/power_series_utils/#Power-Series-Utilities","page":"Power Series Tools","title":"Power Series Utilities","text":"","category":"section"},{"location":"utils/power_series_utils/","page":"Power Series Tools","title":"Power Series Tools","text":"Pages =[\"power_series_utils.md\"]","category":"page"},{"location":"utils/power_series_utils/","page":"Power Series Tools","title":"Power Series Tools","text":"Modules = [StructuralIdentifiability]\nPages   = [\"power_series_utils.jl\"]","category":"page"},{"location":"utils/power_series_utils/#StructuralIdentifiability._matrix_inv_newton_iteration-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}}} where T<:(AbstractAlgebra.AbsSeriesElem{<:AbstractAlgebra.FieldElem})","page":"Power Series Tools","title":"StructuralIdentifiability._matrix_inv_newton_iteration","text":"_matrix_inv_newton_iteration(M, Minv)\n\nPerforms a single step of Newton iteration for inverting M with Minv being a partial result\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_diff-Tuple{AbstractAlgebra.AbsSeriesElem{<:AbstractAlgebra.RingElem}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_diff","text":"ps_diff(ps)\n\nInput:\n\nps - (absolute capped) unvariate power series\n\nOutput: \n\nthe derivative of ps\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_integrate-Tuple{AbstractAlgebra.AbsSeriesElem{<:AbstractAlgebra.FieldElem}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_integrate","text":"ps_integrate(ps)\n\nInput:\n\nps - (absolute capped) unvariate power series\n\nOutput:\n\nthe integral of ps without constant term\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_homlinear_de-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{T}}, AbstractAlgebra.MatElem{<:T}}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{T}}, AbstractAlgebra.MatElem{<:T}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_homlinear_de","text":"ps_matrix_homlinear_de(A, Y0, prec)\n\nInput:\n\nA - a square matrix with entries in a univariate power series ring\nY0 - a square invertible matrix over the base field\n\nOutput: \n\nmatrix Y such that Y' = AY up to precision of A - 1 and Y(0) = Y0\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_inv","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_inv","text":"ps_matrix_inv(M, prec)\n\nInput:\n\nM - a square matrix with entries in a univariate power series ring     it is assumed that M(0) is invertible and all entries having the same precision\nprec - an integer, precision, if -1 then defaults to precision of M\n\nOutput:\n\nthe inverse of M computed up to prec\n\n\n\n\n\n","category":"function"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_linear_de-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{T}}, AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{T}}, AbstractAlgebra.MatElem{<:T}}, Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{T}}, AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{T}}, AbstractAlgebra.MatElem{<:T}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_linear_de","text":"ps_matrix_linear_de(A, B, Y0, prec)\n\nInput:\n\nA, B - square matrices with entries in a univariate power series ring\nY0 - a matrix over the base field with the rows number the same as A\n\nOutput:\n\nmatrix Y such that Y' = AY + B up to precision of A - 1 and Y(0) = Y0\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_matrix_log-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.AbsSeriesElem{<:AbstractAlgebra.FieldElem}}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_matrix_log","text":"ps_matrix_log(M)\n\nInput:\n\nM - a square matrix with entries in a univariate power series ring     it is assumed that M(0) is the identity\n\nOutput: \n\nthe natural log of M\n\n\n\n\n\n","category":"method"},{"location":"utils/power_series_utils/#StructuralIdentifiability.ps_ode_solution-Union{Tuple{P}, Tuple{T}, Tuple{Vector{P}, Dict{P, T}, Dict{P, Vector{T}}, Int64}} where {T<:AbstractAlgebra.FieldElem, P<:AbstractAlgebra.MPolyElem{T}}","page":"Power Series Tools","title":"StructuralIdentifiability.ps_ode_solution","text":"ps_ode_solution(equations, ic, inputs, prec)\n\nInput:\n\nequations - a system of the form A(x u mu)x - B(x u mu) = 0,               where A is a generically nonsingular square matrix. Assumption: A is nonzero at zero\nic - initial conditions for x's (dictionary)\ninputs - power series for inputs represented as arrays (dictionary)\nprec - precision of the solution\n\nOutput: \n\npower series solution of the system\n\n\n\n\n\n","category":"method"},{"location":"identifiability/identifiability/#Functions-to-Assess-Parameter-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/#Assessing-All-Types-of-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"Assessing All Types of Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"assess_identifiability","category":"page"},{"location":"identifiability/identifiability/#StructuralIdentifiability.assess_identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"StructuralIdentifiability.assess_identifiability","text":"assess_identifiability(ode::ODE{P}, p::Float64=0.99) where P <: MPolyElem{fmpq}\n\nInput:\n\node - the ODE model\np - probability of correctness.\n\nAssesses identifiability (both local and global) of a given ODE model (parameters detected automatically). The result is guaranteed to be correct with the probability at least p.\n\n\n\n\n\nassess_identifiability(ode, [funcs_to_check, p=0.99])\n\nInput:\n\node - the ODE model\np - probability of correctness.\n\nAssesses identifiability of a given ODE model. The result is guaranteed to be correct with the probability at least p.\n\nIf funcs_to_check are given, then the function will assess the identifiability of the provided functions and return a list of the same length with each element being one of :nonidentifiable, :locally, :globally.\n\nIf funcs_to_check are not given, the function will assess identifiability of the parameters, and the result will be a dictionary from the parameters to their identifiability properties (again, one of :nonidentifiable, :locally, :globally).\n\n\n\n\n\n","category":"function"},{"location":"identifiability/identifiability/#Assessing-Local-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"Assessing Local Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"assess_local_identifiability","category":"page"},{"location":"identifiability/identifiability/#StructuralIdentifiability.assess_local_identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"StructuralIdentifiability.assess_local_identifiability","text":"assess_local_identifiability(ode::ODE{P}, p::Float64 = 0.99, type=:SE) where P <: MPolyElem{Nemo.fmpq}\n\nInput:\n\node - the ODE model\np - probability of correctness\ntype - identifiability type (:SE for single-experiment, :ME for multi-experiment)\n\nOutput: \n\nfor type=:SE, the result is a dictionary from each parameter to boolean;\nfor type=:ME, the result is a tuple with the dictionary as in :SE case and array of number of experiments.\n\nThe main entrypoint for local identifiability checks.  Call this function to automatically take care of local identifiability of all parameters and initial conditions. The result is correct with probability at least p.\n\ntype can be either :SE (single-experiment identifiability) or :ME (multi-experiment identifiability). The return value is a tuple consisting of the array of bools and the number of experiments to be performed.\n\n\n\n\n\nassess_local_identifiability(ode::ODE{P}, funcs_to_check::Array{<: Any, 1}, p::Float64=0.99, type=:SE) where P <: MPolyElem{Nemo.fmpq}\n\nChecks the local identifiability/observability of the functions in funcs_to_check. The result is correct with probability at least p.\n\nCall this function if you have a specific collection of parameters of which you would like to check local identifiability.\n\ntype can be either :SE (single-experiment identifiability) or :ME (multi-experiment identifiability). If the type is :ME, states are not allowed to appear in the funcs_to_check.\n\n\n\n\n\n","category":"function"},{"location":"identifiability/identifiability/#Assessing-Global-Identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"Assessing Global Identifiability","text":"","category":"section"},{"location":"identifiability/identifiability/","page":"ָFunctions to Assess Parameter Identifiability","title":"ָFunctions to Assess Parameter Identifiability","text":"assess_global_identifiability","category":"page"},{"location":"identifiability/identifiability/#StructuralIdentifiability.assess_global_identifiability","page":"ָFunctions to Assess Parameter Identifiability","title":"StructuralIdentifiability.assess_global_identifiability","text":"assess_global_identifiability(ode::ODE{P}, p::Float64=0.99; var_change=:default, gb_method=:GroebnerBasis) where P <: MPolyElem{fmpq}\n\nInput:\n\node - the ODE model\np - probability of correctness\nvar_change - a policy for variable change (:default, :yes, :no), affects only the runtime\ngb_method - library used for Groebner bases (:GroebnerBasis, :Singular)\n\nOutput: \n\na dictionary mapping each parameter to a boolean.\n\nChecks global identifiability for a parameters of the model provided in ode. Call this function to check global identifiability of all parameters automatically.\n\n\n\n\n\nassess_global_identifiability(ode, [funcs_to_check, p=0.99, var_change=:default, gb_method=:GroebnerBasis])\n\nInput:\n\node - the ODE model\nfuncs_to_check - rational functions in parameters\np - probability of correctness\nvar_change - a policy for variable change (:default, :yes, :no),               affects only the runtime\ngb_method - library used for Groebner bases (:GroebnerBasis, :Singular)\n\nOutput: \n\narray of length length(funcs_to_check) with true/false values for global identifiability       or dictionary param => Bool if funcs_to_check are not given\n\nChecks global identifiability of functions of parameters specified in funcs_to_check.\n\n\n\n\n\n","category":"function"},{"location":"utils/elimination/#Elimination","page":"Elimination","title":"Elimination","text":"","category":"section"},{"location":"utils/elimination/","page":"Elimination","title":"Elimination","text":"Pages=[\"elimination.md\"]","category":"page"},{"location":"utils/elimination/","page":"Elimination","title":"Elimination","text":"Modules = [StructuralIdentifiability]\nPages   = [\"elimination.jl\"]","category":"page"},{"location":"utils/elimination/#StructuralIdentifiability.Bezout_matrix-Union{Tuple{P}, Tuple{P, P, P}} where P<:AbstractAlgebra.MPolyElem","page":"Elimination","title":"StructuralIdentifiability.Bezout_matrix","text":"Bezout_matrix(f, g, var_elim)\n\nCompute the Bezout matrix of two polynomials f, g with respect to var_elim\n\nInputs:\n\nf - first polynomial\ng - second polynomial\nvar_elim - variable, of which f and g are considered as polynomials\n\nOutput:\n\nM::MatrixElem - The Bezout matrix\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.Sylvester_matrix-Union{Tuple{P}, Tuple{P, P, P}} where P<:AbstractAlgebra.MPolyElem","page":"Elimination","title":"StructuralIdentifiability.Sylvester_matrix","text":"Sylvester_matrix(f, g, var_elim)\n\nCompute the Sylvester matrix of two polynomials f, g with respect to var_elim Inputs:\n\nf - first polynomial\ng - second polynomial\nvar_elim - variable, of which f and g are considered as polynomials\n\nOutput:\n\nM::MatrixElem - The Sylvester matrix\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.choose-Union{Tuple{P}, Tuple{Vector{P}, Any}} where P<:(AbstractAlgebra.MPolyElem{<:AbstractAlgebra.FieldElem})","page":"Elimination","title":"StructuralIdentifiability.choose","text":"choose(polys, generic_point_generator)\n\nInput:\n\npolys - an array of distinct irreducible polynomials in the same ring\ngeneric_point_generator - a generic point generator as described above for one of polys\n\nOutput:\n\nthe polynomial that vanishes at the generic_point_generator\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.eliminate_var-Union{Tuple{P}, Tuple{P, P, P, Any}} where P<:(AbstractAlgebra.MPolyElem{<:AbstractAlgebra.FieldElem})","page":"Elimination","title":"StructuralIdentifiability.eliminate_var","text":"eliminate_var(f, g, var_elim, generic_point_generator)\n\nEliminate variable from a pair of polynomials\n\nInput:\n\nf and g - polynomials\nvar_elim - variable to be eliminated\ngeneric_point_generator - a generic point generator object for the factor     of the resultant of f and g of interest\n\nOutput:\n\npolynomial - the desired factor of the resultant of f and g\n\n\n\n\n\n","category":"method"},{"location":"utils/elimination/#StructuralIdentifiability.simplify_matrix-Union{Tuple{AbstractAlgebra.MatElem{P}}, Tuple{P}} where P<:AbstractAlgebra.MPolyElem","page":"Elimination","title":"StructuralIdentifiability.simplify_matrix","text":"simplify_matrix(M)\n\nEliminate GCD of entries of every row and column\n\nInput:\n\nM::MatrixElem - matrix to be simplified\n\nOutput:\n\nM::MatrixElem - Simplified matrix\nextra_factors::Vector{AbstractAlgebra.MPolyElem} - array of GCDs eliminated from M.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/global_identifiability/#Global-Identifiability-of-Differential-Models","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"","category":"section"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"In this tutorial, let us cover an example problem of querying the ODE for globally identifiable parameters.","category":"page"},{"location":"tutorials/global_identifiability/#Input-System","page":"Global Identifiability of Differential Models","title":"Input System","text":"","category":"section"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Let us consider the following four-dimensional model with two outputs:","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"begincasesx(t) = lm - d  x(t) - beta  x(t)  v(t)\n    y(t) = beta  x(t)  v(t) - a  y(t)\n    v(t) = k  y(t) - u  v(t)\n    w(t) = c  x(t)  y(t)  w(t) - c  q  y(t)  w(t) - b  w(t)\n    z(t) = c  q  y(t)  w(t) - h  z(t)\n    y_1(t) = w(t)\n    y_2(t) = z(t)endcases","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"This model describes HIV dynamics[1]. Let us run a global identifiability check on this model to get the result with probability of correctness being p=0.999. To do this, we will use assess_identifiability(ode, p) function.","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Global identifiability needs information about local identifiability first, hence the function we chose here will take care of that extra step for us.","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n    x'(t) = lm - d * x(t) - beta * x(t) * v(t),\n    y'(t) = beta * x(t) * v(t) - a * y(t),\n    v'(t) = k * y(t) - u * v(t),\n    w'(t) = c * x(t) * y(t) * w(t) - c * q * y(t) * w(t) - b * w(t),\n    z'(t) = c * q * y(t) * w(t) - h * z(t),\n    y1(t) = w(t),\n    y2(t) = z(t)\n)\n@time global_id = assess_identifiability(ode, 0.999)","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Now let us compare the same system but with probability being p=0.99. We will see a reduction in runtime:","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n    x'(t) = lm - d * x(t) - beta * x(t) * v(t),\n    y'(t) = beta * x(t) * v(t) - a * y(t),\n    v'(t) = k * y(t) - u * v(t),\n    w'(t) = c * x(t) * y(t) * w(t) - c * q * y(t) * w(t) - b * w(t),\n    z'(t) = c * q * y(t) * w(t) - h * z(t),\n    y1(t) = w(t),\n    y2(t) = z(t)\n)\n@time global_id = assess_identifiability(ode, 0.99)","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"Indeed, notice how much quicker we obtained the result with 99% correctness guarantee! This illustrates the fact that you may sometimes sacrifice probability slightly to get results much faster.","category":"page"},{"location":"tutorials/global_identifiability/","page":"Global Identifiability of Differential Models","title":"Global Identifiability of Differential Models","text":"[1]: D. Wodarz, M. Nowak, Specific therapy regimes could lead to long-term immunological control of HIV, PNAS December 7, 1999 96 (25) 14464-14469;","category":"page"},{"location":"tutorials/local_identifiability/#Local-Identifiability-of-Differential-Models","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"In this tutorial, we will go over an example of solving a local identifiability problem for a simple system of ordinary differential equations.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We will introduce how to use the input parsing in StructuralIdentifiability.jl and the local identifiability assessment functionality.","category":"page"},{"location":"tutorials/local_identifiability/#Input-System","page":"Local Identifiability of Differential Models","title":"Input System","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We will consider a simple two-species competition model","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"x_1 = k (1 - x_1 - x_2) x_2=r(1-x_1-x_2)","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"To make it a proper input for the algorithm, we add an output function y=x_1 that equals to the population density of species 1 at any time t.","category":"page"},{"location":"tutorials/local_identifiability/#Using-the-@ODEmodel-macro","page":"Local Identifiability of Differential Models","title":"Using the @ODEmodel macro","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"To parse the system of ordinary differential equations as above, we will use @ODEmodel macro. This is the easiest way to do so.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We have two state variables x1, x2 (population densities), two parameters k, r (intrinsic growth rates), and one output function y. Note that there must be (t) to indicate time-dependent functions.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"After using the macro, we use assess_local_identifiability function for that. This function accepts the ODE model, the probability of correctness, and the type of identifiability we would like to inquire about.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n\tx1'(t) = k * (1 - x1(t) - x2(t)),\n\tx2'(t) = r * (1 - x1(t) - x2(t)),\n\ty(t) = x1(t)\n)\n\nlocal_id = assess_local_identifiability(ode, 0.99)","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"The result shows that only the state variable's initial value x_1(0) is locally identifiable.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"Let us now add another output function y2(t):","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"using StructuralIdentifiability\n\node = @ODEmodel(\n\tx1'(t) = k * (1 - x1(t) - x2(t)),\n\tx2'(t) = r * (1 - x1(t) - x2(t)),\n\ty1(t) = x1(t),\n\ty2(t) = x2(t) # new output function!\n)\n\nlocal_id = assess_local_identifiability(ode, 0.99) # this is a different result!","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"As you can see, for this new model with an additional output, all parameters are reported as locally identifiable with probability 0.99. ","category":"page"},{"location":"tutorials/local_identifiability/#Note-on-Probability-of-Correctness","page":"Local Identifiability of Differential Models","title":"Note on Probability of Correctness","text":"","category":"section"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"We set the probability of correctness p to be 0.99. Why would we ever want a lower value? Great question! The underlying algorithm relies on operations being modulo a large enough prime characteristic mathcalPgeq kappa p where kappa is determined by the algorithm internally.","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"The algorithm's complexity is proportional to the size of operands (see proposition 3.1 in the main paper[1]) and hence high probability of correctness may lead to higher size of coefficients during computation for some systems hence one may wish to lower p to save on runtime (though in practice this is very rare).","category":"page"},{"location":"tutorials/local_identifiability/","page":"Local Identifiability of Differential Models","title":"Local Identifiability of Differential Models","text":"[1]: A. Sedoglavic, A probabilistic algorithm to test local algebraic observability in polynomial time, Journal of Symbolic Computation, 2002.","category":"page"},{"location":"ioequations/ioequations/#Finding-Input-Output-Equations","page":"Input-Output Equation tools","title":"Finding Input-Output Equations","text":"","category":"section"},{"location":"ioequations/ioequations/","page":"Input-Output Equation tools","title":"Input-Output Equation tools","text":"find_ioequations","category":"page"},{"location":"ioequations/ioequations/#StructuralIdentifiability.find_ioequations","page":"Input-Output Equation tools","title":"StructuralIdentifiability.find_ioequations","text":"find_ioequations(ode, [var_change_policy=:default])\n\nFinds the input-output equations of an ODE system Input:\n\node - the ODE system\nvar_change_policy - whether to perform automatic variable change, can be one of :default, :yes, :no\n\nOutput:\n\na dictionary from \"leaders\" to the corresponding input-output equations\n\n\n\n\n\n","category":"function"},{"location":"utils/local_identifiability/#Local-Identifiability-Tools","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"","category":"section"},{"location":"utils/local_identifiability/","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"Pages=[\"local_identifiability.md\"]","category":"page"},{"location":"utils/local_identifiability/","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"CurrentModule=StructuralIdentifiability","category":"page"},{"location":"utils/local_identifiability/","page":"Local Identifiability Tools","title":"Local Identifiability Tools","text":"StructuralIdentifiability.differentiate_solution\nStructuralIdentifiability.differentiate_output","category":"page"},{"location":"utils/local_identifiability/#StructuralIdentifiability.differentiate_solution","page":"Local Identifiability Tools","title":"StructuralIdentifiability.differentiate_solution","text":"differentiate_solution(ode, params, ic, inputs, prec)\n\nInput: \n\nthe same as for power_series_solutions\n\nOutput: \n\na tuple consisting of the power series solution and a dictionary of the form (u, v) => power series, where u is a state variable  v is a state or parameter, and the power series is the partial derivative of the function u w.r.t. v evaluated at the solution\n\n\n\n\n\n","category":"function"},{"location":"utils/local_identifiability/#StructuralIdentifiability.differentiate_output","page":"Local Identifiability Tools","title":"StructuralIdentifiability.differentiate_output","text":"differentiate_output(ode, params, ic, inputs, prec)\n\nSimilar to differentiate_solution but computes partial derivatives of a prescribed outputs returns a dictionary of the form y_function => Dict(var => dy/dvar) where dy/dvar is the derivative of y_function with respect to var.\n\n\n\n\n\n","category":"function"},{"location":"#StructuralIdentifiability.jl","page":"Home","title":"StructuralIdentifiability.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StructuralIdentifiability.jl is a comprehensive toolbox for assessing identifiability parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation contains information about the functionality of the package as well as examples of use cases.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install StructuralIdentifiability.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"StructuralIdentifiability\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@article{structidjl,\n  author  = {Dong, R. and Goodbrake, C. and Harrington, H. and Pogudin G.},\n  title   = {Structural identifiability via input-output projections},\n  journal = {Manuscript in preparation},\n  year    = {2021}\n}","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StructuralIdentifiability.jl can assess local and global identifiability of ODE models. In addition to these straightforward identifiability queries on individual parameters, the package is able to distinguish between single- and multi-experiment identifiability.","category":"page"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Local identifiability checks\nGlobal identifiability checks\nAssessment of identifiable functions of parameters","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to StructuralIdentifiability.\nThere are a few community forums:\nThe #diffeq-bridged channel in the Julia Slack\nJuliaDiffEq on Gitter\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"utils/ode/#Working-with-ODEs","page":"ODE Tools","title":"Working with ODEs","text":"","category":"section"},{"location":"utils/ode/","page":"ODE Tools","title":"ODE Tools","text":"Pages = [\"ode.md\"]","category":"page"},{"location":"utils/ode/","page":"ODE Tools","title":"ODE Tools","text":"Modules = [StructuralIdentifiability]\nPages   = [\"ODE.jl\"]","category":"page"},{"location":"utils/ode/#StructuralIdentifiability.PreprocessODE-Tuple{ModelingToolkit.ODESystem}","page":"ODE Tools","title":"StructuralIdentifiability.PreprocessODE","text":"function PreprocessODE(de::ModelingToolkit.ODESystem, inputs)\n\nInput:\n\ndiff_eqs - array of ModelingToolkit differential equations\nout_eqs - array of output equations\nstates - array of state variables\noutputs - array of output function names\ninputs - array of input function names\nparameters - array of parameter names\n\nOutput: \n\nODE object containing required data for identifiability assessment\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability._reduce_mod_p-Tuple{Nemo.fmpq_mpoly, Int64}","page":"ODE Tools","title":"StructuralIdentifiability._reduce_mod_p","text":"_reduce_mod_p(f, p)\n\nReduces a polynomial/rational function over Q modulo p\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.power_series_solution-Union{Tuple{P}, Tuple{T}, Tuple{ODE{P}, Dict{P, T}, Dict{P, T}, Dict{P, Vector{T}}, Int64}} where {T<:AbstractAlgebra.FieldElem, P<:AbstractAlgebra.MPolyElem{T}}","page":"ODE Tools","title":"StructuralIdentifiability.power_series_solution","text":"power_series_solution(ode, param_values, initial_conditions, input_values, prec)\n\nInput:\n\node - an ode to solve\nparam_values - parameter values, must be a dictionary mapping parameter to a value\ninitial_conditions - initial conditions of ode, must be a dictionary mapping state variable to a value\ninput_values - power series for the inpiuts presented as a dictionary variable => list of coefficients\nprec - the precision of solutions\n\nOutput: \n\ncomputes a power series solution with precision prec presented as a dictionary variable => corresponding coordiante of the solution\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.reduce_ode_mod_p-Tuple{ODE{<:AbstractAlgebra.MPolyElem{Nemo.fmpq}}, Int64}","page":"ODE Tools","title":"StructuralIdentifiability.reduce_ode_mod_p","text":"reduce_ode_mod_p(ode, p)\n\nInput: ode is an ODE over QQ, p is a prime number Output: the reduction mod p, throws an exception if p divides one of the denominators\n\n\n\n\n\n","category":"method"},{"location":"utils/ode/#StructuralIdentifiability.set_parameter_values-Union{Tuple{P}, Tuple{T}, Tuple{ODE{P}, Dict{P, T}}} where {T<:AbstractAlgebra.FieldElem, P<:AbstractAlgebra.MPolyElem{T}}","page":"ODE Tools","title":"StructuralIdentifiability.set_parameter_values","text":"set_parameter_values(ode, param_values)\n\nInput:\n\node - an ODE as above\nparam_values - values for (possibly, some of) the parameters as dictionary parameter => value\n\nOutput: \n\nnew ode with the parameters in param_values plugged with the given numbers\n\n\n\n\n\n","category":"method"}]
}
